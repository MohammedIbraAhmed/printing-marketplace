# Story 3.1: Payment System Integration

## Status
Draft

## Story
**As a** customer,  
**I want** to pay for orders securely with multiple payment methods,  
**so that** I can complete transactions safely and conveniently.

## Acceptance Criteria

1. **Stripe Connect Setup**: Marketplace payment system configured for multi-party transactions
2. **Checkout Process**: Secure payment flow with multiple payment methods (cards, digital wallets)
3. **Payment Security**: PCI compliance, tokenization, and fraud detection integration
4. **Order Integration**: Payment processing integrated with existing order workflow
5. **Payment Confirmation**: Email confirmations and receipt generation for successful payments
6. **Failed Payment Handling**: Retry logic and customer notifications for payment failures
7. **Transaction Logging**: Comprehensive payment transaction records for accounting and disputes

## Tasks / Subtasks

- [ ] **Task 1: Stripe Connect Configuration** (AC: 1)
  - [ ] Set up Stripe Connect platform account
  - [ ] Configure marketplace application settings
  - [ ] Implement Connect account creation for print shops
  - [ ] Build Connect account onboarding flow
  - [ ] Add Express Dashboard integration for shops

- [ ] **Task 2: Secure Checkout Interface** (AC: 2)
  - [ ] Build checkout page with Stripe Elements
  - [ ] Implement multiple payment methods (cards, Apple Pay, Google Pay)
  - [ ] Create billing address collection and validation
  - [ ] Add payment method saving for returning customers
  - [ ] Build mobile-optimized checkout experience

- [ ] **Task 3: Payment Security Implementation** (AC: 3)
  - [ ] Implement PCI-compliant payment tokenization
  - [ ] Configure Stripe Radar for fraud detection
  - [ ] Add 3D Secure authentication for high-risk transactions
  - [ ] Implement payment method verification
  - [ ] Build security monitoring and alerting

- [ ] **Task 4: Order-Payment Integration** (AC: 4)
  - [ ] Integrate payment flow with order creation workflow
  - [ ] Implement payment intent creation and confirmation
  - [ ] Build payment status tracking in order management
  - [ ] Add payment retry logic for failed transactions
  - [ ] Create payment-order reconciliation system

- [ ] **Task 5: Payment Confirmations and Receipts** (AC: 5)
  - [ ] Build payment confirmation email templates
  - [ ] Create PDF receipt generation system
  - [ ] Implement confirmation page with order details
  - [ ] Add payment notification system for all parties
  - [ ] Build receipt download functionality

- [ ] **Task 6: Failed Payment Management** (AC: 6)
  - [ ] Implement failed payment detection and handling
  - [ ] Build automatic payment retry with exponential backoff
  - [ ] Create failed payment customer notifications
  - [ ] Add manual payment retry options
  - [ ] Build payment method update flow for failures

- [ ] **Task 7: Transaction Logging and Audit Trail** (AC: 7)
  - [ ] Create comprehensive payment transaction logging
  - [ ] Build payment audit trail with status changes
  - [ ] Implement transaction search and filtering
  - [ ] Add financial reconciliation reports
  - [ ] Create payment dispute evidence collection

- [ ] **Task 8: Payment System Testing**
  - [ ] Test payment flows with test cards and scenarios
  - [ ] Test multi-party payment splitting
  - [ ] Test payment failure and retry scenarios
  - [ ] Test webhook handling and order updates
  - [ ] Verify PCI compliance and security measures

## Dev Notes

### Previous Story Insights
**Dependencies from Previous Stories:**
- Story 1.1: Order collection schema with payment integration
- Story 2.4: Order creation system requiring payment processing
- Story 2.5: Order status management connected to payment status
- Story 1.5: Email notification system for payment confirmations

### Stripe Connect Architecture
**Marketplace Payment Setup:**
```typescript
// lib/payments/stripe-connect.ts
import Stripe from 'stripe'

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2023-10-16'
})

export interface ConnectAccount {
  stripeAccountId: string
  userId: string (ref: User)
  businessType: 'individual' | 'company'
  businessInfo: {
    name: string
    type: string
    taxId?: string
    address: Address
    phone: string
    email: string
  }
  requirements: {
    currentlyDue: string[]
    pastDue: string[]
    disabled: boolean
    disabledReason?: string
  }
  capabilities: {
    transfers: 'active' | 'inactive' | 'pending'
    cardPayments: 'active' | 'inactive' | 'pending'
  }
  payoutsEnabled: boolean
  chargesEnabled: boolean
  createdAt: Date
  updatedAt: Date
}

export class StripeConnectManager {
  static async createConnectAccount(
    userId: string, 
    businessInfo: ConnectAccount['businessInfo']
  ): Promise<ConnectAccount> {
    try {
      // Create Stripe Connect Express account
      const account = await stripe.accounts.create({
        type: 'express',
        country: 'US',
        email: businessInfo.email,
        business_type: businessInfo.type as any,
        business_profile: {
          name: businessInfo.name,
          product_description: 'Print shop services',
          support_phone: businessInfo.phone,
          url: `${process.env.NEXTAUTH_URL}/shops/${userId}`
        },
        capabilities: {
          transfers: { requested: true },
          card_payments: { requested: true }
        }
      })

      // Save to database
      const connectAccount = await ConnectAccount.create({
        stripeAccountId: account.id,
        userId,
        businessType: businessInfo.type,
        businessInfo,
        requirements: {
          currentlyDue: account.requirements?.currently_due || [],
          pastDue: account.requirements?.past_due || [],
          disabled: account.requirements?.disabled_reason !== null
        },
        capabilities: {
          transfers: account.capabilities?.transfers || 'inactive',
          cardPayments: account.capabilities?.card_payments || 'inactive'
        },
        payoutsEnabled: account.payouts_enabled || false,
        chargesEnabled: account.charges_enabled || false
      })

      return connectAccount
    } catch (error) {
      console.error('Failed to create Connect account:', error)
      throw new Error('Connect account creation failed')
    }
  }

  static async createAccountLink(accountId: string, userId: string): Promise<string> {
    const accountLink = await stripe.accountLinks.create({
      account: accountId,
      refresh_url: `${process.env.NEXTAUTH_URL}/shop/onboarding/refresh`,
      return_url: `${process.env.NEXTAUTH_URL}/shop/onboarding/complete`,
      type: 'account_onboarding'
    })

    return accountLink.url
  }

  static async createLoginLink(accountId: string): Promise<string> {
    const loginLink = await stripe.accounts.createLoginLink(accountId)
    return loginLink.url
  }

  static async updateAccountRequirements(accountId: string): Promise<void> {
    const account = await stripe.accounts.retrieve(accountId)
    
    await ConnectAccount.findOneAndUpdate(
      { stripeAccountId: accountId },
      {
        requirements: {
          currentlyDue: account.requirements?.currently_due || [],
          pastDue: account.requirements?.past_due || [],
          disabled: account.requirements?.disabled_reason !== null,
          disabledReason: account.requirements?.disabled_reason
        },
        capabilities: {
          transfers: account.capabilities?.transfers || 'inactive',
          cardPayments: account.capabilities?.card_payments || 'inactive'
        },
        payoutsEnabled: account.payouts_enabled || false,
        chargesEnabled: account.charges_enabled || false
      }
    )
  }
}
```

### Payment Integration with Orders
**Order Payment Processing:**
```typescript
// lib/payments/order-payments.ts
export interface PaymentIntent {
  id: string
  orderId: string
  amount: number
  currency: string
  status: 'requires_payment_method' | 'requires_confirmation' | 'requires_action' | 'processing' | 'succeeded' | 'canceled'
  clientSecret: string
  paymentMethod?: string
  transferGroup: string
  applicationFeeAmount: number
  transfers: PaymentTransfer[]
  createdAt: Date
  confirmedAt?: Date
}

export interface PaymentTransfer {
  destinationAccountId: string
  amount: number
  purpose: 'creator_royalty' | 'shop_payment'
  recipientUserId: string
  status: 'pending' | 'paid' | 'failed'
  transferId?: string
}

export class OrderPaymentProcessor {
  static async createPaymentIntent(order: Order): Promise<PaymentIntent> {
    const transferGroup = `order_${order.orderNumber}`
    const applicationFeeAmount = Math.round(order.pricing.serviceFee * 100)
    
    // Calculate transfers
    const transfers = await this.calculateTransfers(order)
    
    // Create Stripe Payment Intent
    const paymentIntent = await stripe.paymentIntents.create({
      amount: Math.round(order.pricing.total * 100),
      currency: 'usd',
      transfer_group: transferGroup,
      application_fee_amount: applicationFeeAmount,
      metadata: {
        orderId: order._id.toString(),
        orderNumber: order.orderNumber,
        customerId: order.customer.userId.toString()
      },
      automatic_payment_methods: {
        enabled: true,
        allow_redirects: 'never'
      }
    })

    // Save payment intent to database
    const orderPayment = await OrderPayment.create({
      id: paymentIntent.id,
      orderId: order._id,
      amount: order.pricing.total,
      currency: 'USD',
      status: paymentIntent.status,
      clientSecret: paymentIntent.client_secret,
      transferGroup,
      applicationFeeAmount: order.pricing.serviceFee,
      transfers
    })

    return orderPayment
  }

  static async confirmPayment(
    paymentIntentId: string, 
    paymentMethodId: string
  ): Promise<PaymentIntent> {
    try {
      // Confirm the payment intent
      const confirmedIntent = await stripe.paymentIntents.confirm(paymentIntentId, {
        payment_method: paymentMethodId,
        return_url: `${process.env.NEXTAUTH_URL}/orders/payment/complete`
      })

      // Update database
      const payment = await OrderPayment.findOneAndUpdate(
        { id: paymentIntentId },
        {
          status: confirmedIntent.status,
          paymentMethod: paymentMethodId,
          confirmedAt: new Date()
        },
        { new: true }
      )

      // Process transfers if payment succeeded
      if (confirmedIntent.status === 'succeeded') {
        await this.processTransfers(payment)
        await this.updateOrderPaymentStatus(payment.orderId, 'succeeded')
      }

      return payment
    } catch (error) {
      console.error('Payment confirmation failed:', error)
      await this.handlePaymentFailure(paymentIntentId, error)
      throw error
    }
  }

  private static async calculateTransfers(order: Order): Promise<PaymentTransfer[]> {
    const transfers: PaymentTransfer[] = []
    
    // Get print shop Connect account
    const shopAccount = await ConnectAccount.findOne({ 
      userId: order.printShop.shopId 
    })
    
    if (!shopAccount) {
      throw new Error('Print shop Connect account not found')
    }

    // Calculate shop payment (total minus platform fee and creator royalties)
    let shopPayment = order.pricing.subtotal - order.pricing.serviceFee
    
    // Process each order item for creator royalties
    for (const item of order.items) {
      if (item.contentId && item.creatorId) {
        const content = await Content.findById(item.contentId)
        const creatorRoyalty = content.pricing.creatorRoyalty || 0
        
        if (creatorRoyalty > 0) {
          const creatorAccount = await ConnectAccount.findOne({ 
            userId: item.creatorId 
          })
          
          if (creatorAccount) {
            transfers.push({
              destinationAccountId: creatorAccount.stripeAccountId,
              amount: creatorRoyalty,
              purpose: 'creator_royalty',
              recipientUserId: item.creatorId.toString(),
              status: 'pending'
            })
            
            shopPayment -= creatorRoyalty
          }
        }
      }
    }

    // Add shop payment transfer
    transfers.push({
      destinationAccountId: shopAccount.stripeAccountId,
      amount: shopPayment,
      purpose: 'shop_payment',
      recipientUserId: order.printShop.shopId.toString(),
      status: 'pending'
    })

    return transfers
  }

  private static async processTransfers(payment: PaymentIntent): Promise<void> {
    for (const transfer of payment.transfers) {
      try {
        const stripeTransfer = await stripe.transfers.create({
          amount: Math.round(transfer.amount * 100),
          currency: 'usd',
          destination: transfer.destinationAccountId,
          transfer_group: payment.transferGroup,
          metadata: {
            orderId: payment.orderId,
            purpose: transfer.purpose,
            recipientUserId: transfer.recipientUserId
          }
        })

        // Update transfer status
        await OrderPayment.findOneAndUpdate(
          { 
            id: payment.id,
            'transfers.destinationAccountId': transfer.destinationAccountId 
          },
          {
            $set: {
              'transfers.$.status': 'paid',
              'transfers.$.transferId': stripeTransfer.id
            }
          }
        )
      } catch (error) {
        console.error('Transfer failed:', error)
        await OrderPayment.findOneAndUpdate(
          { 
            id: payment.id,
            'transfers.destinationAccountId': transfer.destinationAccountId 
          },
          {
            $set: { 'transfers.$.status': 'failed' }
          }
        )
      }
    }
  }

  private static async updateOrderPaymentStatus(
    orderId: string, 
    paymentStatus: string
  ): Promise<void> {
    await Order.findByIdAndUpdate(orderId, {
      'payment.status': paymentStatus,
      'payment.paidAt': new Date()
    })

    // Send payment confirmation notifications
    const order = await Order.findById(orderId).populate('customer.userId')
    await sendPaymentConfirmationEmail(order)
  }

  private static async handlePaymentFailure(
    paymentIntentId: string, 
    error: any
  ): Promise<void> {
    await OrderPayment.findOneAndUpdate(
      { id: paymentIntentId },
      { 
        status: 'failed',
        failureReason: error.message,
        failedAt: new Date()
      }
    )

    // Get order and send failure notification
    const payment = await OrderPayment.findOne({ id: paymentIntentId })
    if (payment) {
      const order = await Order.findById(payment.orderId)
      await sendPaymentFailureEmail(order, error.message)
    }
  }
}
```

### Checkout Component
**Secure Payment Interface:**
```typescript
// components/payments/checkout-form.tsx
'use client'

import { useState } from 'react'
import { useStripe, useElements, PaymentElement } from '@stripe/react-stripe-js'
import { Button } from '@/components/ui/button'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Badge } from '@/components/ui/badge'
import { Separator } from '@/components/ui/separator'
import { Order } from '@/types/orders'

interface CheckoutFormProps {
  order: Order
  clientSecret: string
  onPaymentSuccess: (paymentIntent: any) => void
  onPaymentError: (error: string) => void
}

export function CheckoutForm({ 
  order, 
  clientSecret, 
  onPaymentSuccess, 
  onPaymentError 
}: CheckoutFormProps) {
  const stripe = useStripe()
  const elements = useElements()
  const [isProcessing, setIsProcessing] = useState(false)
  const [paymentError, setPaymentError] = useState<string | null>(null)

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault()

    if (!stripe || !elements) {
      return
    }

    setIsProcessing(true)
    setPaymentError(null)

    try {
      const { error, paymentIntent } = await stripe.confirmPayment({
        elements,
        confirmParams: {
          return_url: `${window.location.origin}/orders/${order._id}/payment/complete`,
        },
        redirect: 'if_required'
      })

      if (error) {
        setPaymentError(error.message || 'Payment failed')
        onPaymentError(error.message || 'Payment failed')
      } else if (paymentIntent.status === 'succeeded') {
        onPaymentSuccess(paymentIntent)
      }
    } catch (err) {
      setPaymentError('An unexpected error occurred')
      onPaymentError('An unexpected error occurred')
    } finally {
      setIsProcessing(false)
    }
  }

  return (
    <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
      {/* Payment Form */}
      <div className="space-y-6">
        <Card>
          <CardHeader>
            <CardTitle>Payment Information</CardTitle>
          </CardHeader>
          <CardContent>
            <form onSubmit={handleSubmit} className="space-y-6">
              <PaymentElement 
                options={{
                  layout: 'tabs',
                  paymentMethodOrder: ['card', 'apple_pay', 'google_pay']
                }}
              />
              
              {paymentError && (
                <div className="p-3 bg-red-50 border border-red-200 rounded-md">
                  <p className="text-sm text-red-600">{paymentError}</p>
                </div>
              )}

              <Button
                type="submit"
                disabled={!stripe || isProcessing}
                className="w-full"
                size="lg"
              >
                {isProcessing ? 'Processing...' : `Pay $${order.pricing.total.toFixed(2)}`}
              </Button>
            </form>
          </CardContent>
        </Card>

        {/* Security Badges */}
        <div className="flex items-center justify-center gap-4 text-sm text-muted-foreground">
          <Badge variant="outline" className="flex items-center gap-2">
            🔒 SSL Encrypted
          </Badge>
          <Badge variant="outline" className="flex items-center gap-2">
            💳 PCI Compliant
          </Badge>
          <Badge variant="outline" className="flex items-center gap-2">
            🛡️ Fraud Protected
          </Badge>
        </div>
      </div>

      {/* Order Summary */}
      <div>
        <Card>
          <CardHeader>
            <CardTitle>Order Summary</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div>
              <h4 className="font-medium">Order #{order.orderNumber}</h4>
              <p className="text-sm text-muted-foreground">
                {order.items.length} item(s) • {order.printShop.businessInfo.name}
              </p>
            </div>

            <Separator />

            {/* Order Items */}
            <div className="space-y-3">
              {order.items.map((item, index) => (
                <div key={index} className="flex justify-between items-start">
                  <div className="flex-1">
                    <p className="font-medium text-sm">{item.fileName}</p>
                    <p className="text-xs text-muted-foreground">
                      {item.specifications.quantity} copies • {item.specifications.colorOption.toUpperCase()}
                    </p>
                  </div>
                  <p className="font-medium text-sm">
                    ${item.pricing.total.toFixed(2)}
                  </p>
                </div>
              ))}
            </div>

            <Separator />

            {/* Pricing Breakdown */}
            <div className="space-y-2 text-sm">
              <div className="flex justify-between">
                <span>Subtotal:</span>
                <span>${order.pricing.subtotal.toFixed(2)}</span>
              </div>
              <div className="flex justify-between">
                <span>Tax:</span>
                <span>${order.pricing.tax.toFixed(2)}</span>
              </div>
              {order.pricing.deliveryFee > 0 && (
                <div className="flex justify-between">
                  <span>Delivery:</span>
                  <span>${order.pricing.deliveryFee.toFixed(2)}</span>
                </div>
              )}
              <div className="flex justify-between">
                <span>Service Fee:</span>
                <span>${order.pricing.serviceFee.toFixed(2)}</span>
              </div>
              <Separator />
              <div className="flex justify-between font-medium">
                <span>Total:</span>
                <span>${order.pricing.total.toFixed(2)}</span>
              </div>
            </div>

            {/* Delivery Information */}
            <Separator />
            <div>
              <h4 className="font-medium text-sm mb-2">
                {order.delivery.method === 'pickup' ? 'Pickup' : 'Delivery'}
              </h4>
              {order.delivery.method === 'pickup' ? (
                <p className="text-sm text-muted-foreground">
                  {order.printShop.businessInfo.location.address}
                </p>
              ) : (
                <p className="text-sm text-muted-foreground">
                  {order.delivery.address?.street}<br />
                  {order.delivery.address?.city}, {order.delivery.address?.state} {order.delivery.address?.zipCode}
                </p>
              )}
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  )
}
```

### Webhook Handling
**Payment Event Processing:**
```typescript
// /api/webhooks/stripe/route.ts
import { headers } from 'next/headers'
import { NextRequest, NextResponse } from 'next/server'
import Stripe from 'stripe'

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!)
const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET!

export async function POST(request: NextRequest) {
  const body = await request.text()
  const signature = headers().get('stripe-signature')!

  let event: Stripe.Event

  try {
    event = stripe.webhooks.constructEvent(body, signature, webhookSecret)
  } catch (err) {
    console.error('Webhook signature verification failed:', err)
    return NextResponse.json({ error: 'Invalid signature' }, { status: 400 })
  }

  try {
    switch (event.type) {
      case 'payment_intent.succeeded':
        await handlePaymentSuccess(event.data.object as Stripe.PaymentIntent)
        break
      case 'payment_intent.payment_failed':
        await handlePaymentFailure(event.data.object as Stripe.PaymentIntent)
        break
      case 'transfer.created':
        await handleTransferCreated(event.data.object as Stripe.Transfer)
        break
      case 'account.updated':
        await handleAccountUpdated(event.data.object as Stripe.Account)
        break
      default:
        console.log(`Unhandled event type: ${event.type}`)
    }

    return NextResponse.json({ received: true })
  } catch (error) {
    console.error('Webhook processing failed:', error)
    return NextResponse.json({ error: 'Webhook processing failed' }, { status: 500 })
  }
}

async function handlePaymentSuccess(paymentIntent: Stripe.PaymentIntent) {
  const orderId = paymentIntent.metadata.orderId
  
  await Promise.all([
    // Update payment status
    OrderPayment.findOneAndUpdate(
      { id: paymentIntent.id },
      { 
        status: 'succeeded',
        paidAt: new Date()
      }
    ),
    
    // Update order status
    Order.findByIdAndUpdate(orderId, {
      'payment.status': 'succeeded',
      'payment.paidAt': new Date(),
      status: 'accepted'
    }),
    
    // Send confirmation emails
    sendPaymentSuccessNotifications(orderId)
  ])
}

async function handlePaymentFailure(paymentIntent: Stripe.PaymentIntent) {
  const orderId = paymentIntent.metadata.orderId
  
  await Promise.all([
    // Update payment status
    OrderPayment.findOneAndUpdate(
      { id: paymentIntent.id },
      { 
        status: 'failed',
        failureReason: paymentIntent.last_payment_error?.message,
        failedAt: new Date()
      }
    ),
    
    // Update order status
    Order.findByIdAndUpdate(orderId, {
      'payment.status': 'failed',
      status: 'payment_failed'
    }),
    
    // Send failure notifications
    sendPaymentFailureNotifications(orderId, paymentIntent.last_payment_error?.message)
  ])
}

async function handleTransferCreated(transfer: Stripe.Transfer) {
  await OrderPayment.findOneAndUpdate(
    { 
      transferGroup: transfer.transfer_group,
      'transfers.destinationAccountId': transfer.destination 
    },
    {
      $set: {
        'transfers.$.transferId': transfer.id,
        'transfers.$.status': 'paid'
      }
    }
  )
}

async function handleAccountUpdated(account: Stripe.Account) {
  await StripeConnectManager.updateAccountRequirements(account.id)
}
```

### File Locations and Project Structure
- **Payment Pages**: `/app/orders/[id]/checkout/page.tsx`, `/app/payments/success/page.tsx`
- **Payment Components**: `/components/payments/checkout-form.tsx`, `/components/payments/payment-status.tsx`
- **Connect Components**: `/components/payments/connect-onboarding.tsx`
- **API Routes**: `/app/api/payments/`, `/app/api/webhooks/stripe/`, `/app/api/connect/`
- **Payment Utils**: `/lib/payments/stripe-connect.ts`, `/lib/payments/order-payments.ts`
- **Payment Types**: `/types/payments.ts`, `/types/stripe.ts`

## Testing

### Test Requirements
**Payment Integration Testing:**
```typescript
// __tests__/lib/payments/order-payments.test.ts
describe('OrderPaymentProcessor', () => {
  it('creates payment intent with correct transfers', async () => {
    const order = await createMockOrder({
      pricing: { total: 100, serviceFee: 15 },
      items: [{ creatorId: 'creator123', pricing: { creatorRoyalty: 20 } }]
    })

    const paymentIntent = await OrderPaymentProcessor.createPaymentIntent(order)
    
    expect(paymentIntent.amount).toBe(100)
    expect(paymentIntent.applicationFeeAmount).toBe(15)
    expect(paymentIntent.transfers).toHaveLength(2) // creator + shop
    expect(paymentIntent.transfers[0].amount).toBe(20) // creator royalty
    expect(paymentIntent.transfers[1].amount).toBe(65) // shop payment (100 - 15 - 20)
  })

  it('handles payment confirmation successfully', async () => {
    const mockPaymentIntent = await createMockPaymentIntent()
    
    const confirmedPayment = await OrderPaymentProcessor.confirmPayment(
      mockPaymentIntent.id,
      'pm_card_visa'
    )

    expect(confirmedPayment.status).toBe('succeeded')
    expect(confirmedPayment.paymentMethod).toBe('pm_card_visa')
    expect(confirmedPayment.confirmedAt).toBeDefined()
  })
})
```

**Stripe Connect Testing:**
```typescript
// __tests__/lib/payments/stripe-connect.test.ts
describe('StripeConnectManager', () => {
  it('creates Connect account with correct business info', async () => {
    const businessInfo = {
      name: 'Test Print Shop',
      type: 'company',
      email: 'shop@test.com',
      phone: '+1234567890',
      address: { /* address info */ }
    }

    const connectAccount = await StripeConnectManager.createConnectAccount(
      'user123',
      businessInfo
    )

    expect(connectAccount.stripeAccountId).toBeDefined()
    expect(connectAccount.businessInfo.name).toBe('Test Print Shop')
    expect(connectAccount.capabilities.cardPayments).toBe('pending')
  })
})
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-16 | 1.0 | Initial story creation from Epic 3 requirements | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by development agent_

### Debug Log References
_To be populated by development agent_

### Completion Notes List
_To be populated by development agent_

### File List
_To be populated by development agent_

## QA Results
_To be populated by QA agent_