# Story 2.4: Basic Order Creation

## Status
Draft

## Story
**As a** customer,  
**I want** to create orders with print specifications and shop selection,  
**so that** I can get my materials printed according to my requirements.

## Acceptance Criteria

1. **Content Selection**: Choose from uploaded content or customer files with preview
2. **Print Configuration**: Select quantity, color options, paper type, and binding preferences
3. **Shop Selection**: Choose from available print shops with pricing and turnaround estimates
4. **Order Summary**: Clear breakdown of content costs, printing fees, and total pricing
5. **Delivery Options**: Choose pickup or delivery with address and time preferences
6. **Order Validation**: Comprehensive validation of order details before submission
7. **Order Creation**: Submit order and generate unique order ID with initial status

## Tasks / Subtasks

- [ ] **Task 1: Content Selection Interface** (AC: 1)
  - [ ] Create content browser for order creation
  - [ ] Implement file upload for custom customer files
  - [ ] Build content preview system with file viewer
  - [ ] Add content validation and compatibility checking
  - [ ] Integrate with content discovery system from Story 2.3

- [ ] **Task 2: Print Configuration System** (AC: 2)
  - [ ] Build comprehensive print options form
  - [ ] Create quantity selector with bulk pricing
  - [ ] Implement color/B&W selection with cost impact
  - [ ] Add paper type and size selection interface
  - [ ] Create binding options with visual preview

- [ ] **Task 3: Print Shop Selection and Comparison** (AC: 3)
  - [ ] Integrate shop directory from Story 2.1
  - [ ] Build shop comparison interface with pricing
  - [ ] Display turnaround times and availability status
  - [ ] Add distance calculation and sorting
  - [ ] Create shop selection with capacity validation

- [ ] **Task 4: Dynamic Order Summary and Pricing** (AC: 4)
  - [ ] Create real-time pricing calculator
  - [ ] Build itemized cost breakdown display
  - [ ] Implement tax calculation and display
  - [ ] Add pricing validation and error handling
  - [ ] Create order total with all fees included

- [ ] **Task 5: Delivery Options Configuration** (AC: 5)
  - [ ] Build pickup/delivery selection interface
  - [ ] Create address input with validation and geocoding
  - [ ] Add delivery time slot selection
  - [ ] Implement special instructions field
  - [ ] Calculate delivery fees and restrictions

- [ ] **Task 6: Order Validation System** (AC: 6)
  - [ ] Implement comprehensive order validation
  - [ ] Create validation error display and handling
  - [ ] Add shop capacity and availability checking
  - [ ] Validate file compatibility and requirements
  - [ ] Check user authentication and permissions

- [ ] **Task 7: Order Submission and Creation** (AC: 7)
  - [ ] Create order submission API endpoint
  - [ ] Generate unique order numbers and tracking
  - [ ] Implement order status initialization
  - [ ] Send confirmation emails to all parties
  - [ ] Create order success page with next steps

- [ ] **Task 8: Order Creation Testing**
  - [ ] Test complete order flow from content to submission
  - [ ] Test validation scenarios and error handling
  - [ ] Test pricing calculations and accuracy
  - [ ] Test shop selection and availability
  - [ ] Verify email notifications and confirmations

## Dev Notes

### Previous Story Insights
**Dependencies from Previous Stories:**
- Story 1.1: Order collection schema with complete order structure
- Story 1.2: Authentication system and file upload capabilities
- Story 2.1: Print shop directory and shop capacity management
- Story 2.2: Content upload system and file processing
- Story 2.3: Content discovery and selection interfaces

### Order Schema Integration
[Source: complete-architecture/database-architecture.md#orders-collection]

**Complete Order Schema:**
```typescript
interface Order {
  _id: ObjectId
  orderNumber: string (unique)
  
  customer: {
    userId: ObjectId (ref: User)
    contactInfo: {
      name: string
      email: string
      phone?: string
    }
    deliveryAddress?: {
      street: string
      city: string
      state: string
      zipCode: string
      country: string
      coordinates: [number, number]
    }
  }
  
  items: [{
    contentId?: ObjectId (ref: Content) // null for customer uploads
    creatorId?: ObjectId (ref: User)
    fileUrl: string
    fileName: string
    fileKey: string
    specifications: {
      quantity: number
      colorOption: 'bw' | 'color'
      paperSize: 'A4' | 'A3' | 'Letter' | 'Legal'
      paperType: 'standard' | 'premium' | 'photo'
      binding?: 'none' | 'staple' | 'spiral' | 'perfect'
      lamination?: boolean
      customInstructions?: string
    }
    pricing: {
      contentCost: number
      printingCost: number
      bindingCost: number
      laminationCost: number
      total: number
    }
  }]
  
  printShop: {
    shopId: ObjectId (ref: User)
    estimatedCompletion: Date
    actualCompletion?: Date
    confirmationDeadline: Date
  }
  
  delivery: {
    method: 'pickup' | 'delivery'
    address?: Address
    timeSlot?: {
      date: Date
      startTime: string
      endTime: string
    }
    instructions?: string
    cost: number
  }
  
  pricing: {
    subtotal: number
    tax: number
    deliveryFee: number
    serviceFee: number
    total: number
    currency: 'USD'
  }
  
  status: 'pending' | 'accepted' | 'in_progress' | 'ready' | 'completed' | 'cancelled'
  statusHistory: [{
    status: string
    timestamp: Date
    note?: string
    updatedBy: ObjectId (ref: User)
  }]
  
  payment: {
    stripePaymentIntentId?: string
    amount: number
    currency: string
    platformFee: number
    creatorFee: number
    shopFee: number
    status: 'pending' | 'succeeded' | 'failed'
    paidAt?: Date
  }
  
  createdAt: Date
  updatedAt: Date
}
```

### Order Creation API
**Comprehensive Order Creation Endpoint:**
```typescript
// /api/orders/create/route.ts
export async function POST(request: NextRequest) {
  const session = await auth()
  if (!session?.user || session.user.role !== 'customer') {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
  }

  try {
    const orderData = await request.json()
    
    // Validate order data
    const validatedOrder = orderCreateSchema.parse(orderData)
    
    // Generate unique order number
    const orderNumber = await generateOrderNumber()
    
    // Calculate pricing
    const pricing = await calculateOrderPricing(validatedOrder)
    
    // Validate shop availability
    const shop = await validateShopAvailability(validatedOrder.shopId, validatedOrder.estimatedCompletion)
    
    // Create order
    const order = await Order.create({
      orderNumber,
      customer: {
        userId: session.user.id,
        contactInfo: validatedOrder.contactInfo,
        deliveryAddress: validatedOrder.deliveryAddress
      },
      items: await processOrderItems(validatedOrder.items),
      printShop: {
        shopId: validatedOrder.shopId,
        estimatedCompletion: validatedOrder.estimatedCompletion,
        confirmationDeadline: new Date(Date.now() + 24 * 60 * 60 * 1000) // 24 hours
      },
      delivery: validatedOrder.delivery,
      pricing,
      status: 'pending',
      statusHistory: [{
        status: 'pending',
        timestamp: new Date(),
        note: 'Order created',
        updatedBy: session.user.id
      }],
      payment: {
        amount: pricing.total,
        currency: 'USD',
        platformFee: pricing.serviceFee,
        creatorFee: calculateCreatorFee(validatedOrder.items),
        shopFee: pricing.subtotal - calculateCreatorFee(validatedOrder.items),
        status: 'pending'
      }
    })

    // Update shop capacity
    await updateShopCapacity(validatedOrder.shopId, 1)
    
    // Send notifications
    await Promise.all([
      sendOrderConfirmationEmail(order, session.user),
      sendNewOrderNotificationToShop(order),
      sendOrderNotificationToCreators(order)
    ])

    return NextResponse.json({
      order: {
        id: order._id,
        orderNumber: order.orderNumber,
        status: order.status,
        total: order.pricing.total,
        estimatedCompletion: order.printShop.estimatedCompletion
      }
    }, { status: 201 })

  } catch (error) {
    console.error('Order creation failed:', error)
    return NextResponse.json({ 
      error: error instanceof z.ZodError ? 'Invalid order data' : 'Order creation failed' 
    }, { status: 400 })
  }
}

async function calculateOrderPricing(orderData: any): Promise<OrderPricing> {
  let subtotal = 0
  
  for (const item of orderData.items) {
    // Content cost
    if (item.contentId) {
      const content = await Content.findById(item.contentId)
      subtotal += content.pricing.basePrice
    }
    
    // Printing costs
    const printCost = calculatePrintingCost(item.specifications)
    subtotal += printCost
  }
  
  const serviceFee = Math.max(0.99, subtotal * 0.05) // 5% platform fee, min $0.99
  const tax = subtotal * 0.08 // 8% tax
  const deliveryFee = orderData.delivery.method === 'delivery' ? 
    calculateDeliveryFee(orderData.delivery.address) : 0
  
  return {
    subtotal,
    tax,
    deliveryFee,
    serviceFee,
    total: subtotal + tax + deliveryFee + serviceFee,
    currency: 'USD'
  }
}
```

### Order Creation Components
**Multi-Step Order Form:**
```typescript
// components/orders/order-creation-wizard.tsx
interface OrderCreationWizardProps {
  onOrderComplete: (order: Order) => void
}

export function OrderCreationWizard({ onOrderComplete }: OrderCreationWizardProps) {
  const [currentStep, setCurrentStep] = useState(1)
  const [orderData, setOrderData] = useState<Partial<OrderData>>({})
  const [isSubmitting, setIsSubmitting] = useState(false)

  const steps = [
    { id: 1, title: 'Select Content', component: ContentSelectionStep },
    { id: 2, title: 'Print Options', component: PrintOptionsStep },
    { id: 3, title: 'Choose Shop', component: ShopSelectionStep },
    { id: 4, title: 'Delivery', component: DeliveryOptionsStep },
    { id: 5, title: 'Review', component: OrderReviewStep }
  ]

  const handleStepComplete = (stepData: any) => {
    setOrderData(prev => ({ ...prev, ...stepData }))
    if (currentStep < steps.length) {
      setCurrentStep(prev => prev + 1)
    }
  }

  const handleSubmitOrder = async () => {
    setIsSubmitting(true)
    try {
      const response = await fetch('/api/orders/create', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(orderData)
      })
      
      if (response.ok) {
        const { order } = await response.json()
        onOrderComplete(order)
      } else {
        throw new Error('Order creation failed')
      }
    } catch (error) {
      console.error('Order submission failed:', error)
    } finally {
      setIsSubmitting(false)
    }
  }

  const CurrentStepComponent = steps[currentStep - 1].component

  return (
    <div className="max-w-4xl mx-auto p-6">
      {/* Progress Indicator */}
      <div className="mb-8">
        <div className="flex justify-between items-center">
          {steps.map((step, index) => (
            <div
              key={step.id}
              className={cn(
                "flex items-center",
                index < steps.length - 1 && "flex-1"
              )}
            >
              <div className={cn(
                "w-8 h-8 rounded-full flex items-center justify-center text-sm font-medium",
                currentStep >= step.id ? "bg-blue-500 text-white" : "bg-gray-200 text-gray-600"
              )}>
                {currentStep > step.id ? <Check className="w-4 h-4" /> : step.id}
              </div>
              <span className="ml-2 text-sm">{step.title}</span>
              {index < steps.length - 1 && (
                <div className={cn(
                  "flex-1 h-0.5 mx-4",
                  currentStep > step.id ? "bg-blue-500" : "bg-gray-200"
                )} />
              )}
            </div>
          ))}
        </div>
      </div>

      {/* Step Content */}
      <CurrentStepComponent
        data={orderData}
        onComplete={handleStepComplete}
        onBack={() => setCurrentStep(prev => Math.max(1, prev - 1))}
        isLastStep={currentStep === steps.length}
        onSubmit={handleSubmitOrder}
        isSubmitting={isSubmitting}
      />
    </div>
  )
}
```

### Print Options Configuration
**Comprehensive Print Specifications:**
```typescript
// components/orders/print-options-step.tsx
export function PrintOptionsStep({ data, onComplete }: StepProps) {
  const [specifications, setSpecifications] = useState<PrintSpecifications>({
    quantity: 1,
    colorOption: 'bw',
    paperSize: 'A4',
    paperType: 'standard',
    binding: 'none',
    lamination: false,
    customInstructions: ''
  })

  const [pricing, setPricing] = useState<PrintPricing | null>(null)

  // Calculate pricing in real-time
  useEffect(() => {
    if (data.selectedContent || data.uploadedFiles) {
      calculatePrintPricing(specifications).then(setPricing)
    }
  }, [specifications, data])

  const printOptions = {
    paperSizes: [
      { value: 'A4', label: 'A4 (8.3" × 11.7")', popular: true },
      { value: 'A3', label: 'A3 (11.7" × 16.5")', popular: false },
      { value: 'Letter', label: 'Letter (8.5" × 11")', popular: true },
      { value: 'Legal', label: 'Legal (8.5" × 14")', popular: false }
    ],
    paperTypes: [
      { value: 'standard', label: 'Standard (20lb)', cost: 0, popular: true },
      { value: 'premium', label: 'Premium (24lb)', cost: 0.02, popular: false },
      { value: 'photo', label: 'Photo Paper', cost: 0.15, popular: false }
    ],
    bindingOptions: [
      { value: 'none', label: 'No Binding', cost: 0, popular: true },
      { value: 'staple', label: 'Stapled Corner', cost: 0.50, popular: true },
      { value: 'spiral', label: 'Spiral Bound', cost: 2.00, popular: false },
      { value: 'perfect', label: 'Perfect Bound', cost: 5.00, popular: false }
    ]
  }

  return (
    <div className="space-y-8">
      <div>
        <h2 className="text-2xl font-bold mb-4">Configure Print Options</h2>
        <p className="text-muted-foreground">
          Customize how your materials will be printed
        </p>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
        <div className="space-y-6">
          {/* Quantity */}
          <div>
            <Label className="text-base font-medium">Quantity</Label>
            <div className="flex items-center gap-3 mt-2">
              <Button
                variant="outline"
                size="icon"
                onClick={() => setSpecifications(prev => ({ 
                  ...prev, 
                  quantity: Math.max(1, prev.quantity - 1) 
                }))}
              >
                <Minus className="h-4 w-4" />
              </Button>
              <Input
                type="number"
                min="1"
                max="1000"
                value={specifications.quantity}
                onChange={(e) => setSpecifications(prev => ({ 
                  ...prev, 
                  quantity: parseInt(e.target.value) || 1 
                }))}
                className="w-20 text-center"
              />
              <Button
                variant="outline"
                size="icon"
                onClick={() => setSpecifications(prev => ({ 
                  ...prev, 
                  quantity: prev.quantity + 1 
                }))}
              >
                <Plus className="h-4 w-4" />
              </Button>
            </div>
          </div>

          {/* Color Option */}
          <div>
            <Label className="text-base font-medium">Color Option</Label>
            <RadioGroup
              value={specifications.colorOption}
              onValueChange={(value) => setSpecifications(prev => ({ 
                ...prev, 
                colorOption: value as 'bw' | 'color' 
              }))}
              className="mt-2"
            >
              <div className="flex items-center space-x-2">
                <RadioGroupItem value="bw" id="bw" />
                <Label htmlFor="bw">Black & White</Label>
                <Badge variant="secondary" className="ml-2">Most Popular</Badge>
              </div>
              <div className="flex items-center space-x-2">
                <RadioGroupItem value="color" id="color" />
                <Label htmlFor="color">Full Color</Label>
                <span className="text-sm text-muted-foreground ml-2">
                  +${((pricing?.colorUpcharge || 0) * specifications.quantity).toFixed(2)}
                </span>
              </div>
            </RadioGroup>
          </div>

          {/* Paper Size */}
          <div>
            <Label className="text-base font-medium">Paper Size</Label>
            <Select
              value={specifications.paperSize}
              onValueChange={(value) => setSpecifications(prev => ({ 
                ...prev, 
                paperSize: value 
              }))}
            >
              <SelectTrigger className="mt-2">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                {printOptions.paperSizes.map(size => (
                  <SelectItem key={size.value} value={size.value}>
                    <div className="flex items-center justify-between w-full">
                      <span>{size.label}</span>
                      {size.popular && (
                        <Badge variant="secondary" className="ml-2 text-xs">
                          Popular
                        </Badge>
                      )}
                    </div>
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          {/* Additional Options */}
          <div className="space-y-4">
            <div className="flex items-center space-x-2">
              <Checkbox
                id="lamination"
                checked={specifications.lamination}
                onCheckedChange={(checked) => setSpecifications(prev => ({ 
                  ...prev, 
                  lamination: checked as boolean 
                }))}
              />
              <Label htmlFor="lamination">Lamination</Label>
              <span className="text-sm text-muted-foreground">
                +${(2.00 * specifications.quantity).toFixed(2)}
              </span>
            </div>
          </div>
        </div>

        {/* Live Pricing Preview */}
        <div className="bg-gray-50 p-6 rounded-lg">
          <h3 className="font-semibold mb-4">Pricing Breakdown</h3>
          {pricing && (
            <div className="space-y-2 text-sm">
              <div className="flex justify-between">
                <span>Content:</span>
                <span>${pricing.contentCost.toFixed(2)}</span>
              </div>
              <div className="flex justify-between">
                <span>Printing ({specifications.quantity} copies):</span>
                <span>${pricing.printingCost.toFixed(2)}</span>
              </div>
              {specifications.binding !== 'none' && (
                <div className="flex justify-between">
                  <span>Binding:</span>
                  <span>${pricing.bindingCost.toFixed(2)}</span>
                </div>
              )}
              {specifications.lamination && (
                <div className="flex justify-between">
                  <span>Lamination:</span>
                  <span>${pricing.laminationCost.toFixed(2)}</span>
                </div>
              )}
              <Separator />
              <div className="flex justify-between font-medium">
                <span>Total:</span>
                <span>${pricing.total.toFixed(2)}</span>
              </div>
            </div>
          )}
        </div>
      </div>

      <div className="flex justify-between">
        <Button variant="outline" onClick={onBack}>
          Back
        </Button>
        <Button
          onClick={() => onComplete({ specifications, pricing })}
          disabled={!pricing}
        >
          Continue to Shop Selection
        </Button>
      </div>
    </div>
  )
}
```

### Shop Selection with Comparison
**Shop Selection and Comparison Interface:**
```typescript
// components/orders/shop-selection-step.tsx
export function ShopSelectionStep({ data, onComplete }: StepProps) {
  const [selectedShop, setSelectedShop] = useState<string | null>(null)
  const [userLocation, setUserLocation] = useState<Coordinates | null>(null)
  const [shops, setShops] = useState<PrintShop[]>([])

  useEffect(() => {
    // Get user location and nearby shops
    getCurrentLocation().then(setUserLocation)
    fetchNearbyShops(data.specifications).then(setShops)
  }, [data])

  return (
    <div className="space-y-6">
      <div>
        <h2 className="text-2xl font-bold mb-4">Choose a Print Shop</h2>
        <p className="text-muted-foreground">
          Select a print shop based on price, distance, and availability
        </p>
      </div>

      <div className="grid gap-4">
        {shops.map(shop => (
          <ShopComparisonCard
            key={shop._id}
            shop={shop}
            userLocation={userLocation}
            orderSpecs={data.specifications}
            isSelected={selectedShop === shop._id}
            onSelect={() => setSelectedShop(shop._id)}
          />
        ))}
      </div>

      <div className="flex justify-between">
        <Button variant="outline" onClick={onBack}>
          Back
        </Button>
        <Button
          onClick={() => onComplete({ selectedShop })}
          disabled={!selectedShop}
        >
          Continue to Delivery
        </Button>
      </div>
    </div>
  )
}
```

### File Locations and Project Structure
- **Order Pages**: `/app/orders/new/page.tsx`, `/app/orders/[id]/page.tsx`
- **Order Components**: `/components/orders/order-creation-wizard.tsx`, `/components/orders/print-options-step.tsx`
- **API Routes**: `/app/api/orders/create/`, `/app/api/orders/pricing/`, `/app/api/orders/validate/`
- **Order Utils**: `/lib/orders/pricing.ts`, `/lib/orders/validation.ts`
- **Order Types**: `/types/orders.ts`

## Testing

### Test Requirements
**Order Creation Testing:**
```typescript
// __tests__/api/orders/create.test.ts
describe('/api/orders/create', () => {
  it('creates order with valid data', async () => {
    const orderData = {
      items: [{
        contentId: 'content123',
        specifications: {
          quantity: 10,
          colorOption: 'bw',
          paperSize: 'A4'
        }
      }],
      shopId: 'shop123',
      delivery: { method: 'pickup' }
    }

    const response = await POST('/api/orders/create', orderData)
    
    expect(response.status).toBe(201)
    expect(response.body.order.orderNumber).toBeDefined()
  })
})
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-16 | 1.0 | Initial story creation from Epic 2 requirements | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by development agent_

### Debug Log References
_To be populated by development agent_

### Completion Notes List
_To be populated by development agent_

### File List
_To be populated by development agent_

## QA Results
_To be populated by QA agent_