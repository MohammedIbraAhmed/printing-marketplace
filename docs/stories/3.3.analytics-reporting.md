# Story 3.3: Analytics & Reporting

## Status
Draft

## Story
**As a** platform user,  
**I want** comprehensive analytics and insights,  
**so that** I can understand performance and make informed decisions.

## Acceptance Criteria

1. **Customer Analytics**: Order history, spending patterns, preferred shops, and content recommendations
2. **Creator Dashboard**: Content performance, conversion rates, revenue tracking, and optimization suggestions
3. **Print Shop Metrics**: Order volume, revenue trends, customer ratings, and capacity utilization
4. **Platform Analytics**: GMV, user growth, transaction metrics, and business intelligence
5. **Predictive Insights**: AI-powered suggestions for pricing, content creation, and demand forecasting
6. **Custom Reports**: Configurable dashboards and exportable reports for all user types
7. **Mobile Analytics**: Full analytics functionality optimized for mobile devices

## Tasks / Subtasks

- [ ] **Task 1: Customer Analytics Dashboard** (AC: 1)
  - [ ] Build comprehensive order history analytics
  - [ ] Create spending pattern analysis and trends
  - [ ] Implement preferred shop and content tracking
  - [ ] Add personalized recommendation insights
  - [ ] Create customer journey and behavior analytics

- [ ] **Task 2: Creator Performance Dashboard** (AC: 2)
  - [ ] Build content performance metrics and analytics
  - [ ] Implement conversion rate tracking and optimization
  - [ ] Create revenue analytics with trend analysis
  - [ ] Add content popularity and engagement metrics
  - [ ] Build creator optimization recommendation engine

- [ ] **Task 3: Print Shop Business Intelligence** (AC: 3)
  - [ ] Create comprehensive order volume analytics
  - [ ] Build revenue trend analysis and forecasting
  - [ ] Implement customer satisfaction and rating analytics
  - [ ] Add capacity utilization and efficiency metrics
  - [ ] Create competitive analysis and market insights

- [ ] **Task 4: Platform-Wide Analytics** (AC: 4)
  - [ ] Build gross merchandise value (GMV) tracking
  - [ ] Implement user growth and retention analytics
  - [ ] Create transaction and payment analytics
  - [ ] Add marketplace health and performance metrics
  - [ ] Build executive dashboard for business intelligence

- [ ] **Task 5: Predictive Analytics Engine** (AC: 5)
  - [ ] Implement demand forecasting algorithms
  - [ ] Build pricing optimization recommendations
  - [ ] Create content creation opportunity analysis
  - [ ] Add seasonal trend prediction and planning
  - [ ] Build AI-powered business insights

- [ ] **Task 6: Custom Reporting System** (AC: 6)
  - [ ] Create configurable dashboard builder
  - [ ] Implement custom report generation
  - [ ] Build data export functionality (CSV, PDF, Excel)
  - [ ] Add scheduled report delivery system
  - [ ] Create report sharing and collaboration tools

- [ ] **Task 7: Mobile Analytics Experience** (AC: 7)
  - [ ] Optimize analytics for mobile viewing
  - [ ] Create mobile-specific dashboard layouts
  - [ ] Implement touch-friendly chart interactions
  - [ ] Add mobile report generation and sharing
  - [ ] Build offline analytics sync capabilities

- [ ] **Task 8: Analytics System Testing**
  - [ ] Test data accuracy and calculation methods
  - [ ] Test dashboard performance with large datasets
  - [ ] Test mobile responsive analytics interfaces
  - [ ] Test export functionality and report generation
  - [ ] Verify predictive analytics accuracy

## Dev Notes

### Previous Story Insights
**Dependencies from Previous Stories:**
- Story 1.1: User and order schemas with analytics tracking
- Story 2.2: Content metadata for performance analytics
- Story 3.1: Payment data for revenue analytics
- Story 3.2: Payout data for financial analytics

### Analytics Data Architecture
**Comprehensive Analytics Schema:**
```typescript
// lib/analytics/data-models.ts
export interface UserAnalytics {
  userId: string
  period: 'daily' | 'weekly' | 'monthly' | 'yearly'
  startDate: Date
  endDate: Date
  
  // Customer metrics
  orders: {
    total: number
    completed: number
    cancelled: number
    averageValue: number
    totalSpent: number
  }
  
  // Behavioral metrics
  sessions: {
    total: number
    averageDuration: number
    pagesPerSession: number
    bounceRate: number
  }
  
  // Engagement metrics
  content: {
    viewed: number
    ordered: number
    favorites: number
    shares: number
  }
  
  // Preference patterns
  preferences: {
    topCategories: string[]
    preferredShops: string[]
    averageOrderValue: number
    orderFrequency: number
  }
  
  createdAt: Date
  updatedAt: Date
}

export interface ContentAnalytics {
  contentId: string
  creatorId: string
  period: 'daily' | 'weekly' | 'monthly' | 'yearly'
  startDate: Date
  endDate: Date
  
  // Performance metrics
  views: {
    total: number
    unique: number
    returning: number
    averageTime: number
  }
  
  // Conversion metrics
  conversion: {
    viewToOrder: number
    orderCount: number
    conversionRate: number
    averageOrderValue: number
  }
  
  // Revenue metrics
  revenue: {
    total: number
    royalties: number
    averagePerOrder: number
    growth: number
  }
  
  // Engagement metrics
  engagement: {
    ratings: number
    averageRating: number
    reviews: number
    shares: number
    downloads: number
  }
  
  // SEO and discovery
  discovery: {
    searchImpressions: number
    searchClicks: number
    searchRank: number
    organicTraffic: number
  }
  
  createdAt: Date
  updatedAt: Date
}

export interface ShopAnalytics {
  shopId: string
  period: 'daily' | 'weekly' | 'monthly' | 'yearly'
  startDate: Date
  endDate: Date
  
  // Order metrics
  orders: {
    total: number
    completed: number
    cancelled: number
    averageValue: number
    totalRevenue: number
  }
  
  // Operational metrics
  operations: {
    averageCompletionTime: number
    onTimeDeliveryRate: number
    capacityUtilization: number
    activeHours: number
  }
  
  // Customer satisfaction
  satisfaction: {
    averageRating: number
    totalReviews: number
    repeatCustomerRate: number
    issueRate: number
  }
  
  // Financial metrics
  financials: {
    revenue: number
    payouts: number
    averageOrderMargin: number
    revenueGrowth: number
  }
  
  // Market position
  market: {
    marketShare: number
    competitorComparison: number
    pricePositioning: string
    demandForecast: number
  }
  
  createdAt: Date
  updatedAt: Date
}

export interface PlatformAnalytics {
  period: 'daily' | 'weekly' | 'monthly' | 'yearly'
  startDate: Date
  endDate: Date
  
  // Business metrics
  business: {
    gmv: number // Gross Merchandise Value
    revenue: number
    platformFees: number
    transactionCount: number
    averageOrderValue: number
  }
  
  // User metrics
  users: {
    total: number
    new: number
    active: number
    retained: number
    churnRate: number
  }
  
  // Marketplace health
  marketplace: {
    activeShops: number
    activeCreators: number
    contentItems: number
    orderFulfillmentRate: number
    customerSatisfaction: number
  }
  
  // Growth metrics
  growth: {
    userGrowthRate: number
    revenueGrowthRate: number
    orderGrowthRate: number
    marketExpansion: number
  }
  
  // Performance metrics
  performance: {
    averagePageLoadTime: number
    apiResponseTime: number
    uptime: number
    errorRate: number
  }
  
  createdAt: Date
  updatedAt: Date
}
```

### Analytics Processing Engine
**Real-time Analytics Processing:**
```typescript
// lib/analytics/processing-engine.ts
export class AnalyticsProcessor {
  private static readonly BATCH_SIZE = 1000
  private static readonly PROCESS_INTERVAL = 60000 // 1 minute
  
  static async processRealtimeEvent(event: AnalyticsEvent): Promise<void> {
    try {
      switch (event.type) {
        case 'page_view':
          await this.processPageView(event)
          break
        case 'order_created':
          await this.processOrderEvent(event)
          break
        case 'content_viewed':
          await this.processContentView(event)
          break
        case 'user_signup':
          await this.processUserSignup(event)
          break
        case 'payment_completed':
          await this.processPaymentEvent(event)
          break
      }
      
      // Update real-time dashboards
      await this.updateRealtimeDashboards(event)
      
    } catch (error) {
      console.error('Analytics processing failed:', error)
      await this.logProcessingError(event, error)
    }
  }
  
  static async processBatchAnalytics(): Promise<void> {
    const periods = ['daily', 'weekly', 'monthly']
    
    for (const period of periods) {
      await Promise.all([
        this.processUserAnalytics(period),
        this.processContentAnalytics(period),
        this.processShopAnalytics(period),
        this.processPlatformAnalytics(period)
      ])
    }
  }
  
  private static async processUserAnalytics(period: string): Promise<void> {
    const dateRange = this.getDateRange(period)
    const users = await User.find({ role: 'customer' })
    
    for (const user of users) {
      const analytics = await this.calculateUserAnalytics(user._id, dateRange)
      
      await UserAnalytics.findOneAndUpdate(
        {
          userId: user._id,
          period,
          startDate: dateRange.start,
          endDate: dateRange.end
        },
        analytics,
        { upsert: true }
      )
    }
  }
  
  private static async calculateUserAnalytics(
    userId: string,
    dateRange: { start: Date; end: Date }
  ): Promise<Partial<UserAnalytics>> {
    // Get user orders
    const orders = await Order.find({
      'customer.userId': userId,
      createdAt: { $gte: dateRange.start, $lte: dateRange.end }
    })
    
    // Get user sessions
    const sessions = await UserSession.find({
      userId,
      createdAt: { $gte: dateRange.start, $lte: dateRange.end }
    })
    
    // Get content interactions
    const contentViews = await ContentView.find({
      userId,
      createdAt: { $gte: dateRange.start, $lte: dateRange.end }
    })
    
    // Calculate metrics
    const orderMetrics = {
      total: orders.length,
      completed: orders.filter(o => o.status === 'completed').length,
      cancelled: orders.filter(o => o.status === 'cancelled').length,
      averageValue: orders.reduce((sum, o) => sum + o.pricing.total, 0) / orders.length || 0,
      totalSpent: orders.reduce((sum, o) => sum + o.pricing.total, 0)
    }
    
    const sessionMetrics = {
      total: sessions.length,
      averageDuration: sessions.reduce((sum, s) => sum + s.duration, 0) / sessions.length || 0,
      pagesPerSession: sessions.reduce((sum, s) => sum + s.pageViews, 0) / sessions.length || 0,
      bounceRate: sessions.filter(s => s.pageViews === 1).length / sessions.length || 0
    }
    
    const contentMetrics = {
      viewed: contentViews.length,
      ordered: orders.filter(o => o.items.some(item => item.contentId)).length,
      favorites: await this.getUserFavoriteCount(userId, dateRange),
      shares: await this.getUserShareCount(userId, dateRange)
    }
    
    const preferences = await this.calculateUserPreferences(userId, orders)
    
    return {
      userId: userId.toString(),
      period: dateRange.period,
      startDate: dateRange.start,
      endDate: dateRange.end,
      orders: orderMetrics,
      sessions: sessionMetrics,
      content: contentMetrics,
      preferences,
      updatedAt: new Date()
    }
  }
  
  private static async processContentAnalytics(period: string): Promise<void> {
    const dateRange = this.getDateRange(period)
    const contents = await Content.find({ status: 'approved' })
    
    for (const content of contents) {
      const analytics = await this.calculateContentAnalytics(content._id, dateRange)
      
      await ContentAnalytics.findOneAndUpdate(
        {
          contentId: content._id,
          period,
          startDate: dateRange.start,
          endDate: dateRange.end
        },
        analytics,
        { upsert: true }
      )
    }
  }
  
  private static async calculateContentAnalytics(
    contentId: string,
    dateRange: { start: Date; end: Date }
  ): Promise<Partial<ContentAnalytics>> {
    // Get content views
    const views = await ContentView.find({
      contentId,
      createdAt: { $gte: dateRange.start, $lte: dateRange.end }
    })
    
    // Get orders containing this content
    const orders = await Order.find({
      'items.contentId': contentId,
      createdAt: { $gte: dateRange.start, $lte: dateRange.end }
    })
    
    // Get reviews and ratings
    const reviews = await ContentReview.find({
      contentId,
      createdAt: { $gte: dateRange.start, $lte: dateRange.end }
    })
    
    // Calculate metrics
    const viewMetrics = {
      total: views.length,
      unique: new Set(views.map(v => v.userId)).size,
      returning: views.filter(v => v.isReturn).length,
      averageTime: views.reduce((sum, v) => sum + v.duration, 0) / views.length || 0
    }
    
    const conversionMetrics = {
      viewToOrder: orders.length,
      orderCount: orders.length,
      conversionRate: orders.length / viewMetrics.unique || 0,
      averageOrderValue: orders.reduce((sum, o) => 
        sum + o.items.filter(item => item.contentId?.toString() === contentId)
                   .reduce((itemSum, item) => itemSum + item.pricing.total, 0), 0
      ) / orders.length || 0
    }
    
    const revenueMetrics = await this.calculateContentRevenue(contentId, dateRange)
    
    const engagementMetrics = {
      ratings: reviews.length,
      averageRating: reviews.reduce((sum, r) => sum + r.rating, 0) / reviews.length || 0,
      reviews: reviews.filter(r => r.comment).length,
      shares: await this.getContentShareCount(contentId, dateRange),
      downloads: orders.reduce((sum, o) => 
        sum + o.items.filter(item => item.contentId?.toString() === contentId).length, 0
      )
    }
    
    return {
      contentId: contentId.toString(),
      period: dateRange.period,
      startDate: dateRange.start,
      endDate: dateRange.end,
      views: viewMetrics,
      conversion: conversionMetrics,
      revenue: revenueMetrics,
      engagement: engagementMetrics,
      updatedAt: new Date()
    }
  }
}
```

### Dashboard Components
**Analytics Dashboard Architecture:**
```typescript
// components/analytics/analytics-dashboard.tsx
interface AnalyticsDashboardProps {
  userRole: 'customer' | 'creator' | 'shop' | 'admin'
  userId?: string
  timeframe?: '7d' | '30d' | '90d' | '1y'
}

export function AnalyticsDashboard({ 
  userRole, 
  userId, 
  timeframe = '30d' 
}: AnalyticsDashboardProps) {
  const [selectedMetrics, setSelectedMetrics] = useState<string[]>([])
  const [chartType, setChartType] = useState<'line' | 'bar' | 'pie'>('line')
  const [isLoading, setIsLoading] = useState(true)
  
  const { data: analyticsData } = useQuery({
    queryKey: ['analytics', userRole, userId, timeframe],
    queryFn: () => fetchAnalyticsData(userRole, userId, timeframe),
    refetchInterval: 60000 // Refresh every minute
  })
  
  const dashboardConfig = getDashboardConfig(userRole)
  
  return (
    <div className="space-y-6">
      {/* Dashboard Header */}
      <div className="flex justify-between items-center">
        <h1 className="text-3xl font-bold">
          {dashboardConfig.title}
        </h1>
        <div className="flex gap-2">
          <TimeframeSelector 
            value={timeframe} 
            onChange={setTimeframe}
          />
          <DashboardCustomizer 
            config={dashboardConfig}
            onConfigChange={updateDashboardConfig}
          />
        </div>
      </div>
      
      {/* Key Metrics Cards */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        {dashboardConfig.keyMetrics.map((metric) => (
          <MetricCard
            key={metric.key}
            title={metric.title}
            value={analyticsData?.[metric.key]?.current}
            previousValue={analyticsData?.[metric.key]?.previous}
            format={metric.format}
            trend={analyticsData?.[metric.key]?.trend}
            target={metric.target}
          />
        ))}
      </div>
      
      {/* Charts Section */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {dashboardConfig.charts.map((chart) => (
          <AnalyticsChart
            key={chart.id}
            title={chart.title}
            type={chart.type}
            data={analyticsData?.charts?.[chart.id]}
            config={chart.config}
            timeframe={timeframe}
          />
        ))}
      </div>
      
      {/* Insights and Recommendations */}
      {userRole !== 'customer' && (
        <AnalyticsInsights
          data={analyticsData}
          userRole={userRole}
          onActionTaken={handleInsightAction}
        />
      )}
      
      {/* Detailed Tables */}
      <AnalyticsTable
        title={dashboardConfig.table.title}
        data={analyticsData?.table}
        columns={dashboardConfig.table.columns}
        exportable={true}
      />
    </div>
  )
}

function getDashboardConfig(userRole: string) {
  const configs = {
    customer: {
      title: 'Your Activity Dashboard',
      keyMetrics: [
        { key: 'totalOrders', title: 'Total Orders', format: 'number' },
        { key: 'totalSpent', title: 'Total Spent', format: 'currency' },
        { key: 'favoriteShops', title: 'Favorite Shops', format: 'number' },
        { key: 'savedContent', title: 'Saved Items', format: 'number' }
      ],
      charts: [
        { id: 'orderHistory', title: 'Order History', type: 'line' },
        { id: 'spendingByCategory', title: 'Spending by Category', type: 'pie' },
        { id: 'shopPreferences', title: 'Shop Preferences', type: 'bar' },
        { id: 'monthlySpending', title: 'Monthly Spending', type: 'line' }
      ],
      table: {
        title: 'Recent Orders',
        columns: ['date', 'orderNumber', 'shop', 'items', 'total', 'status']
      }
    },
    
    creator: {
      title: 'Creator Analytics',
      keyMetrics: [
        { key: 'totalRevenue', title: 'Total Revenue', format: 'currency', target: 1000 },
        { key: 'contentViews', title: 'Content Views', format: 'number' },
        { key: 'conversionRate', title: 'Conversion Rate', format: 'percentage', target: 0.05 },
        { key: 'averageRating', title: 'Average Rating', format: 'rating', target: 4.5 }
      ],
      charts: [
        { id: 'revenueOverTime', title: 'Revenue Over Time', type: 'line' },
        { id: 'contentPerformance', title: 'Content Performance', type: 'bar' },
        { id: 'customerGeography', title: 'Customer Geography', type: 'map' },
        { id: 'seasonalTrends', title: 'Seasonal Trends', type: 'line' }
      ],
      table: {
        title: 'Content Performance',
        columns: ['title', 'views', 'orders', 'revenue', 'rating', 'lastOrdered']
      }
    },
    
    shop: {
      title: 'Shop Performance Dashboard',
      keyMetrics: [
        { key: 'monthlyRevenue', title: 'Monthly Revenue', format: 'currency', target: 5000 },
        { key: 'orderVolume', title: 'Orders This Month', format: 'number', target: 100 },
        { key: 'customerRating', title: 'Customer Rating', format: 'rating', target: 4.5 },
        { key: 'capacityUtilization', title: 'Capacity Used', format: 'percentage', target: 0.8 }
      ],
      charts: [
        { id: 'dailyOrders', title: 'Daily Order Volume', type: 'bar' },
        { id: 'revenueBreakdown', title: 'Revenue Breakdown', type: 'pie' },
        { id: 'customerSatisfaction', title: 'Customer Satisfaction', type: 'line' },
        { id: 'operationalMetrics', title: 'Operational Efficiency', type: 'gauge' }
      ],
      table: {
        title: 'Recent Orders',
        columns: ['orderNumber', 'customer', 'items', 'value', 'status', 'completion']
      }
    },
    
    admin: {
      title: 'Platform Analytics',
      keyMetrics: [
        { key: 'gmv', title: 'Gross Merchandise Value', format: 'currency' },
        { key: 'activeUsers', title: 'Active Users', format: 'number' },
        { key: 'transactionVolume', title: 'Transactions', format: 'number' },
        { key: 'platformRevenue', title: 'Platform Revenue', format: 'currency' }
      ],
      charts: [
        { id: 'gmvTrend', title: 'GMV Trend', type: 'line' },
        { id: 'userGrowth', title: 'User Growth', type: 'line' },
        { id: 'marketplaceHealth', title: 'Marketplace Health', type: 'gauge' },
        { id: 'geographicDistribution', title: 'Geographic Distribution', type: 'map' }
      ],
      table: {
        title: 'Top Performing Shops',
        columns: ['shop', 'orders', 'revenue', 'rating', 'growth']
      }
    }
  }
  
  return configs[userRole] || configs.customer
}
```

### Predictive Analytics Engine
**AI-Powered Business Insights:**
```typescript
// lib/analytics/predictive-engine.ts
export class PredictiveAnalyticsEngine {
  static async generateDemandForecast(
    timeframe: '30d' | '90d' | '1y',
    category?: string
  ): Promise<DemandForecast> {
    // Get historical order data
    const historicalData = await this.getHistoricalOrderData(timeframe, category)
    
    // Apply time series forecasting
    const forecast = await this.applyTimeSeriesForecasting(historicalData)
    
    // Consider seasonal patterns
    const seasonalAdjustment = await this.calculateSeasonalAdjustment(historicalData)
    
    // Factor in external trends
    const externalFactors = await this.getExternalMarketFactors()
    
    return {
      period: timeframe,
      category,
      forecast: this.adjustForecastWithFactors(forecast, seasonalAdjustment, externalFactors),
      confidence: this.calculateConfidence(historicalData, forecast),
      recommendations: await this.generateDemandRecommendations(forecast)
    }
  }
  
  static async generatePricingOptimization(
    contentId: string
  ): Promise<PricingOptimization> {
    const content = await Content.findById(contentId)
    const performanceData = await this.getContentPerformanceData(contentId)
    
    // Analyze price elasticity
    const priceElasticity = await this.calculatePriceElasticity(performanceData)
    
    // Compare with similar content
    const competitiveAnalysis = await this.performCompetitiveAnalysis(content)
    
    // Calculate optimal price points
    const optimalPricing = await this.calculateOptimalPricing(
      priceElasticity,
      competitiveAnalysis,
      performanceData
    )
    
    return {
      currentPrice: content.pricing.basePrice,
      suggestedPrice: optimalPricing.optimal,
      priceRange: optimalPricing.range,
      expectedImpact: optimalPricing.impact,
      reasoning: optimalPricing.reasoning,
      confidence: optimalPricing.confidence
    }
  }
  
  static async generateContentOpportunities(
    creatorId: string
  ): Promise<ContentOpportunity[]> {
    // Analyze creator's existing content performance
    const creatorContent = await Content.find({ creatorId })
    const performanceAnalysis = await this.analyzeCreatorPerformance(creatorContent)
    
    // Identify market gaps
    const marketGaps = await this.identifyMarketGaps()
    
    // Analyze trending topics
    const trendingTopics = await this.getTrendingTopics()
    
    // Match creator strengths with opportunities
    const opportunities = await this.matchOpportunities(
      performanceAnalysis,
      marketGaps,
      trendingTopics
    )
    
    return opportunities.map(opp => ({
      category: opp.category,
      topic: opp.topic,
      estimatedDemand: opp.demand,
      competitionLevel: opp.competition,
      suggestedPrice: opp.pricing,
      expectedRevenue: opp.revenue,
      confidence: opp.confidence,
      actionItems: opp.actions
    }))
  }
  
  static async generateBusinessInsights(
    userRole: string,
    userId?: string
  ): Promise<BusinessInsight[]> {
    const insights: BusinessInsight[] = []
    
    switch (userRole) {
      case 'creator':
        insights.push(...await this.generateCreatorInsights(userId))
        break
      case 'shop':
        insights.push(...await this.generateShopInsights(userId))
        break
      case 'admin':
        insights.push(...await this.generatePlatformInsights())
        break
    }
    
    return insights.sort((a, b) => b.priority - a.priority)
  }
  
  private static async generateCreatorInsights(creatorId: string): Promise<BusinessInsight[]> {
    const insights: BusinessInsight[] = []
    
    // Revenue optimization insights
    const revenueData = await this.getCreatorRevenueData(creatorId)
    if (revenueData.trend < 0) {
      insights.push({
        type: 'revenue_decline',
        title: 'Revenue Decline Detected',
        description: 'Your revenue has declined by 15% this month. Consider reviewing pricing or creating new content.',
        impact: 'high',
        priority: 8,
        actions: [
          'Review and optimize content pricing',
          'Create content in trending categories',
          'Engage with customer feedback'
        ]
      })
    }
    
    // Content performance insights
    const underperformingContent = await this.getUnderperformingContent(creatorId)
    if (underperformingContent.length > 0) {
      insights.push({
        type: 'content_optimization',
        title: 'Content Optimization Opportunity',
        description: `${underperformingContent.length} content items have low engagement. Consider updates or promotions.`,
        impact: 'medium',
        priority: 6,
        actions: [
          'Update content descriptions and tags',
          'Lower prices for promotional period',
          'Request feedback from recent customers'
        ]
      })
    }
    
    // Seasonal opportunities
    const seasonalOpportunities = await this.getSeasonalOpportunities(creatorId)
    if (seasonalOpportunities.length > 0) {
      insights.push({
        type: 'seasonal_opportunity',
        title: 'Seasonal Content Opportunity',
        description: 'Back-to-school season is approaching. Consider creating relevant educational content.',
        impact: 'high',
        priority: 7,
        actions: [
          'Create back-to-school themed content',
          'Optimize for relevant keywords',
          'Plan promotional campaigns'
        ]
      })
    }
    
    return insights
  }
  
  private static async applyTimeSeriesForecasting(data: any[]): Promise<any> {
    // Simplified time series forecasting
    // In production, you might use more sophisticated algorithms like ARIMA, Prophet, or ML models
    
    const values = data.map(d => d.value)
    const trend = this.calculateLinearTrend(values)
    const seasonality = this.calculateSeasonality(values)
    
    const forecastPeriods = 30 // 30 days ahead
    const forecast = []
    
    for (let i = 0; i < forecastPeriods; i++) {
      const trendValue = trend.slope * (values.length + i) + trend.intercept
      const seasonalValue = seasonality[i % seasonality.length]
      const forecastValue = Math.max(0, trendValue + seasonalValue)
      
      forecast.push({
        date: new Date(Date.now() + i * 24 * 60 * 60 * 1000),
        value: forecastValue,
        confidence: Math.max(0.5, 1 - (i * 0.02)) // Decreasing confidence over time
      })
    }
    
    return forecast
  }
  
  private static calculateLinearTrend(values: number[]): { slope: number; intercept: number } {
    const n = values.length
    const sumX = n * (n - 1) / 2
    const sumY = values.reduce((sum, val) => sum + val, 0)
    const sumXY = values.reduce((sum, val, i) => sum + i * val, 0)
    const sumX2 = n * (n - 1) * (2 * n - 1) / 6
    
    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX)
    const intercept = (sumY - slope * sumX) / n
    
    return { slope, intercept }
  }
  
  private static calculateSeasonality(values: number[]): number[] {
    // Calculate weekly seasonality (7-day cycle)
    const weeklyPattern = new Array(7).fill(0)
    const counts = new Array(7).fill(0)
    
    values.forEach((value, index) => {
      const dayOfWeek = index % 7
      weeklyPattern[dayOfWeek] += value
      counts[dayOfWeek]++
    })
    
    // Calculate average for each day of week
    const avgPattern = weeklyPattern.map((sum, i) => 
      counts[i] > 0 ? sum / counts[i] : 0
    )
    
    // Calculate overall average
    const overallAvg = avgPattern.reduce((sum, val) => sum + val, 0) / 7
    
    // Return deviation from average
    return avgPattern.map(val => val - overallAvg)
  }
}
```

### File Locations and Project Structure
- **Analytics Pages**: `/app/analytics/page.tsx`, `/app/creator/analytics/page.tsx`, `/app/shop/analytics/page.tsx`
- **Dashboard Components**: `/components/analytics/analytics-dashboard.tsx`, `/components/analytics/metric-card.tsx`
- **Chart Components**: `/components/analytics/analytics-chart.tsx`, `/components/analytics/trend-chart.tsx`
- **Insight Components**: `/components/analytics/insights-panel.tsx`, `/components/analytics/recommendations.tsx`
- **API Routes**: `/app/api/analytics/`, `/app/api/reports/`, `/app/api/insights/`
- **Analytics Engine**: `/lib/analytics/processing-engine.ts`, `/lib/analytics/predictive-engine.ts`
- **Background Jobs**: `/lib/jobs/analytics-processor.ts`, `/lib/jobs/report-generator.ts`

## Testing

### Test Requirements
**Analytics Processing Testing:**
```typescript
// __tests__/lib/analytics/processing-engine.test.ts
describe('AnalyticsProcessor', () => {
  it('calculates user analytics correctly', async () => {
    const userId = 'user123'
    const dateRange = { 
      start: new Date('2024-01-01'), 
      end: new Date('2024-01-31'),
      period: 'monthly'
    }

    // Create test data
    await createMockOrders(userId, 5, dateRange)
    await createMockSessions(userId, 10, dateRange)

    const analytics = await AnalyticsProcessor.calculateUserAnalytics(userId, dateRange)
    
    expect(analytics.orders.total).toBe(5)
    expect(analytics.sessions.total).toBe(10)
    expect(analytics.orders.averageValue).toBeGreaterThan(0)
  })

  it('processes real-time events correctly', async () => {
    const event = {
      type: 'order_created',
      userId: 'user123',
      orderId: 'order456',
      value: 100,
      timestamp: new Date()
    }

    await AnalyticsProcessor.processRealtimeEvent(event)
    
    const userAnalytics = await UserAnalytics.findOne({ userId: 'user123' })
    expect(userAnalytics.orders.total).toBeGreaterThanOrEqual(1)
  })
})
```

**Predictive Analytics Testing:**
```typescript
// __tests__/lib/analytics/predictive-engine.test.ts
describe('PredictiveAnalyticsEngine', () => {
  it('generates demand forecast', async () => {
    const historicalData = createMockHistoricalData(90) // 90 days of data
    
    const forecast = await PredictiveAnalyticsEngine.generateDemandForecast('30d')
    
    expect(forecast.forecast).toHaveLength(30)
    expect(forecast.confidence).toBeGreaterThan(0.5)
    expect(forecast.recommendations).toBeDefined()
  })

  it('generates pricing optimization', async () => {
    const contentId = 'content123'
    const mockContent = await createMockContent(contentId, { price: 10 })
    
    const optimization = await PredictiveAnalyticsEngine.generatePricingOptimization(contentId)
    
    expect(optimization.suggestedPrice).toBeGreaterThan(0)
    expect(optimization.confidence).toBeDefined()
    expect(optimization.expectedImpact).toBeDefined()
  })
})
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-16 | 1.0 | Initial story creation from Epic 3 requirements | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by development agent_

### Debug Log References
_To be populated by development agent_

### Completion Notes List
_To be populated by development agent_

### File List
_To be populated by development agent_

## QA Results
_To be populated by QA agent_