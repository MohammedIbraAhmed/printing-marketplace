# Story 2.3: Educational Content Discovery System

## Status
Draft

## Story
**As a** student/customer,  
**I want** to search and browse educational materials effectively,  
**so that** I can find relevant content for my printing needs.

## Acceptance Criteria

1. **Search Functionality**: Text search across titles, descriptions, and tags with autocomplete
2. **Advanced Filters**: Filter by subject, grade level, content type, price range, and creator ratings
3. **Content Display**: Responsive grid and list views with thumbnails, titles, creators, and pricing
4. **Content Detail Pages**: Comprehensive view with description, preview, creator info, and print options
5. **Rating System**: Display average ratings and customer reviews with sorting capabilities
6. **Recommendations**: Algorithm-based content suggestions based on viewing history
7. **Mobile Optimization**: Touch-friendly browse experience optimized for mobile discovery

## Tasks / Subtasks

- [ ] **Task 1: Search Infrastructure and API** (AC: 1)
  - [ ] Implement full-text search using MongoDB text indexes
  - [ ] Create search API with autocomplete functionality
  - [ ] Build search query parsing and relevance scoring
  - [ ] Add search analytics and popular search tracking
  - [ ] Implement search result caching for performance

- [ ] **Task 2: Advanced Filtering System** (AC: 2)
  - [ ] Create comprehensive filter API with multiple criteria support
  - [ ] Build filter UI components with real-time updates
  - [ ] Implement price range slider and grade level multi-select
  - [ ] Add creator rating filter with star display
  - [ ] Create filter persistence in URL parameters

- [ ] **Task 3: Content Display Interfaces** (AC: 3, 7)
  - [ ] Build responsive content grid with lazy loading
  - [ ] Create content list view with detailed information
  - [ ] Implement content card components with thumbnails
  - [ ] Add view switching (grid/list) with user preference saving
  - [ ] Optimize for mobile touch interactions and performance

- [ ] **Task 4: Content Detail Pages** (AC: 4)
  - [ ] Create comprehensive content detail page layout
  - [ ] Implement file preview system with PDF viewer
  - [ ] Build creator profile integration with content showcase
  - [ ] Add print option calculator with real-time pricing
  - [ ] Create related content suggestions section

- [ ] **Task 5: Rating and Review System** (AC: 5)
  - [ ] Implement content rating submission interface
  - [ ] Build review display with pagination and sorting
  - [ ] Create rating aggregation and display components
  - [ ] Add review moderation and spam protection
  - [ ] Implement helpful/unhelpful review voting

- [ ] **Task 6: Recommendation Engine** (AC: 6)
  - [ ] Build content recommendation algorithm
  - [ ] Implement user viewing history tracking
  - [ ] Create collaborative filtering for similar users
  - [ ] Add trending content detection and display
  - [ ] Build personalized content suggestions API

- [ ] **Task 7: Mobile-Optimized Discovery Experience** (AC: 7)
  - [ ] Optimize search interface for mobile keyboards
  - [ ] Implement touch-friendly filter controls
  - [ ] Create mobile-specific content browsing patterns
  - [ ] Add infinite scroll for mobile content discovery
  - [ ] Optimize images and loading for mobile networks

- [ ] **Task 8: Content Discovery Testing**
  - [ ] Test search functionality with various queries
  - [ ] Test filter combinations and performance
  - [ ] Test mobile responsive design and interactions
  - [ ] Test recommendation accuracy and relevance
  - [ ] Verify content detail page functionality

## Dev Notes

### Previous Story Insights
**Dependencies from Previous Stories:**
- Story 1.1: Content collection schema with full-text search indexes
- Story 2.1: Print shop integration for pricing calculations
- Story 2.2: Content upload system and metadata structure

### Content Schema for Discovery
[Source: complete-architecture/database-architecture.md#content-collection]

**Enhanced Content Schema for Search:**
```typescript
interface Content {
  // ... base content fields from Story 2.2
  
  // Discovery and search fields
  searchKeywords: string[]        // Generated keywords for search
  popularity: {
    viewCount: number
    orderCount: number
    recentViews: number          // Views in last 30 days
    trendingScore: number        // Algorithm-calculated trending score
  }
  
  ratings: {
    average: number              // Average rating (1-5)
    count: number               // Total number of ratings
    distribution: {             // Rating distribution
      1: number, 2: number, 3: number, 4: number, 5: number
    }
  }
  
  reviews: [{
    userId: ObjectId (ref: User)
    rating: number              // 1-5 stars
    comment: string
    helpful: number             // Helpful votes
    notHelpful: number          // Not helpful votes
    createdAt: Date
    verified: boolean           // Verified purchase
  }]
  
  // SEO and discovery
  slug: string                  // URL-friendly identifier
  metaDescription: string       // SEO meta description
  featuredUntil?: Date         // Featured content expiry
  
  createdAt: Date
  updatedAt: Date
}
```

### Search Infrastructure
[Source: complete-architecture/database-architecture.md#database-indexes]

**Enhanced Search Indexes:**
```javascript
// Full-text search index
db.content.createIndex({
  "$text": {
    title: 1,
    description: 1,
    "metadata.tags": 1,
    searchKeywords: 1
  }
}, {
  weights: {
    title: 10,
    "metadata.tags": 5,
    searchKeywords: 3,
    description: 1
  }
})

// Filtering and sorting indexes
db.content.createIndex({ "metadata.subject": 1, "metadata.gradeLevel": 1, status: 1 })
db.content.createIndex({ "ratings.average": -1, "popularity.orderCount": -1 })
db.content.createIndex({ "popularity.trendingScore": -1, createdAt: -1 })
db.content.createIndex({ "pricing.basePrice": 1, status: 1 })
```

### Search API Implementation
**Advanced Search Functionality:**
```typescript
// /api/content/search/route.ts
export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url)
  const query = searchParams.get('q') || ''
  const subject = searchParams.get('subject')
  const gradeLevel = searchParams.getAll('gradeLevel')
  const minPrice = parseFloat(searchParams.get('minPrice') || '0')
  const maxPrice = parseFloat(searchParams.get('maxPrice') || '1000')
  const minRating = parseFloat(searchParams.get('minRating') || '0')
  const sortBy = searchParams.get('sortBy') || 'relevance'
  const page = parseInt(searchParams.get('page') || '1')
  const limit = parseInt(searchParams.get('limit') || '20')

  try {
    // Build search pipeline
    const pipeline: any[] = [
      // Text search stage
      ...(query ? [{
        $match: {
          $text: { $search: query },
          status: 'approved'
        }
      }, {
        $addFields: {
          score: { $meta: "textScore" }
        }
      }] : [{
        $match: { status: 'approved' }
      }]),
      
      // Filtering stage
      {
        $match: {
          ...(subject && { "metadata.subject": subject }),
          ...(gradeLevel.length > 0 && { "metadata.gradeLevel": { $in: gradeLevel } }),
          "pricing.basePrice": { $gte: minPrice, $lte: maxPrice },
          "ratings.average": { $gte: minRating }
        }
      },
      
      // Population stage
      {
        $lookup: {
          from: "users",
          localField: "creatorId",
          foreignField: "_id",
          as: "creator",
          pipeline: [
            { $project: { name: 1, "profile.bio": 1, "ratings.average": 1 } }
          ]
        }
      },
      { $unwind: "$creator" },
      
      // Sorting stage
      {
        $sort: getSortCriteria(sortBy)
      },
      
      // Pagination
      { $skip: (page - 1) * limit },
      { $limit: limit }
    ]

    const [results, totalCount] = await Promise.all([
      Content.aggregate(pipeline),
      Content.countDocuments(pipeline[0].$match)
    ])

    // Track search analytics
    await trackSearchQuery(query, results.length)

    return NextResponse.json({
      content: results,
      pagination: {
        page,
        limit,
        total: totalCount,
        pages: Math.ceil(totalCount / limit)
      },
      filters: {
        subjects: await getAvailableSubjects(),
        gradeLevels: await getAvailableGradeLevels(),
        priceRange: await getPriceRange()
      }
    })
  } catch (error) {
    return NextResponse.json({ error: 'Search failed' }, { status: 500 })
  }
}

function getSortCriteria(sortBy: string) {
  switch (sortBy) {
    case 'relevance':
      return { score: { $meta: "textScore" }, "popularity.trendingScore": -1 }
    case 'rating':
      return { "ratings.average": -1, "ratings.count": -1 }
    case 'price-low':
      return { "pricing.basePrice": 1 }
    case 'price-high':
      return { "pricing.basePrice": -1 }
    case 'newest':
      return { createdAt: -1 }
    case 'popular':
      return { "popularity.orderCount": -1, "popularity.viewCount": -1 }
    default:
      return { "popularity.trendingScore": -1 }
  }
}
```

### Content Discovery Components
**Advanced Search Interface:**
```typescript
// components/content/content-search.tsx
interface ContentSearchProps {
  initialQuery?: string
  onResults?: (results: SearchResults) => void
}

export function ContentSearch({ initialQuery = '', onResults }: ContentSearchProps) {
  const [query, setQuery] = useState(initialQuery)
  const [filters, setFilters] = useState<SearchFilters>({
    subject: '',
    gradeLevel: [],
    priceRange: [0, 100],
    minRating: 0
  })
  const [sortBy, setSortBy] = useState('relevance')
  const [viewMode, setViewMode] = useState<'grid' | 'list'>('grid')
  const [suggestions, setSuggestions] = useState<string[]>([])

  const debouncedQuery = useDebounce(query, 300)
  const debouncedFilters = useDebounce(filters, 500)

  // Search with debouncing
  const { data: searchResults, isLoading } = useQuery({
    queryKey: ['content-search', debouncedQuery, debouncedFilters, sortBy],
    queryFn: () => searchContent({
      query: debouncedQuery,
      filters: debouncedFilters,
      sortBy
    }),
    keepPreviousData: true
  })

  // Autocomplete suggestions
  const { data: autocompleteSuggestions } = useQuery({
    queryKey: ['search-suggestions', query],
    queryFn: () => getSearchSuggestions(query),
    enabled: query.length >= 2
  })

  return (
    <div className="space-y-6">
      {/* Search Bar with Autocomplete */}
      <div className="relative">
        <div className="relative">
          <Search className="absolute left-3 top-3 h-4 w-4 text-muted-foreground" />
          <Input
            placeholder="Search educational materials..."
            value={query}
            onChange={(e) => setQuery(e.target.value)}
            className="pl-10 pr-4 py-2 text-base"
          />
        </div>
        
        {/* Autocomplete Dropdown */}
        {autocompleteSuggestions && autocompleteSuggestions.length > 0 && (
          <div className="absolute z-10 w-full mt-1 bg-white border rounded-md shadow-lg">
            {autocompleteSuggestions.map((suggestion, index) => (
              <button
                key={index}
                className="w-full px-4 py-2 text-left hover:bg-gray-50 border-b last:border-b-0"
                onClick={() => setQuery(suggestion)}
              >
                {suggestion}
              </button>
            ))}
          </div>
        )}
      </div>

      {/* Filters and Controls */}
      <div className="flex flex-col lg:flex-row gap-4 items-start lg:items-center justify-between">
        <ContentFilters
          filters={filters}
          onChange={setFilters}
          availableOptions={searchResults?.filters}
        />
        
        <div className="flex gap-2 items-center">
          <Select value={sortBy} onValueChange={setSortBy}>
            <SelectTrigger className="w-40">
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="relevance">Relevance</SelectItem>
              <SelectItem value="rating">Highest Rated</SelectItem>
              <SelectItem value="price-low">Price: Low to High</SelectItem>
              <SelectItem value="price-high">Price: High to Low</SelectItem>
              <SelectItem value="newest">Newest</SelectItem>
              <SelectItem value="popular">Most Popular</SelectItem>
            </SelectContent>
          </Select>
          
          <ViewModeToggle mode={viewMode} onChange={setViewMode} />
        </div>
      </div>

      {/* Search Results */}
      {isLoading ? (
        <ContentSearchSkeleton />
      ) : (
        <ContentSearchResults
          results={searchResults}
          viewMode={viewMode}
          onContentSelect={handleContentSelect}
        />
      )}
    </div>
  )
}
```

### Content Card Component
[Source: complete-architecture/component-architecture.md#content-card]

**Enhanced Content Card for Discovery:**
```typescript
// components/content/content-card.tsx
interface ContentCardProps {
  content: Content & {
    creator: Pick<User, 'name' | 'profile'>
  }
  variant?: 'grid' | 'list' | 'featured'
  showCreator?: boolean
  showRating?: boolean
  onSelect?: (content: Content) => void
}

export function ContentCard({ 
  content, 
  variant = 'grid', 
  showCreator = true, 
  showRating = true, 
  onSelect 
}: ContentCardProps) {
  const cardClass = cn(
    "group cursor-pointer transition-all duration-200 hover:shadow-lg",
    {
      "hover:scale-[1.02] active:scale-[0.98]": variant === 'grid',
      "flex flex-row": variant === 'list',
      "bg-gradient-to-r from-blue-50 to-purple-50 p-6": variant === 'featured'
    }
  )

  return (
    <Card className={cardClass} onClick={() => onSelect?.(content)}>
      {/* Thumbnail */}
      <div className={cn(
        "relative overflow-hidden",
        variant === 'list' ? "w-32 h-24 flex-shrink-0" : "aspect-[3/4] w-full"
      )}>
        <Image
          src={content.file.thumbnailUrl || '/placeholder-document.png'}
          alt={content.title}
          fill
          className="object-cover transition-transform group-hover:scale-105"
        />
        
        {/* Price Badge */}
        <Badge className="absolute top-2 right-2 bg-green-500">
          ${content.pricing.basePrice.toFixed(2)}
        </Badge>
        
        {/* Featured Badge */}
        {variant === 'featured' && (
          <Badge className="absolute top-2 left-2 bg-yellow-500">
            Featured
          </Badge>
        )}
      </div>

      <div className={cn(
        "p-4 space-y-2",
        variant === 'list' && "flex-1"
      )}>
        {/* Title and Subject */}
        <div className="space-y-1">
          <h3 className={cn(
            "font-semibold line-clamp-2",
            variant === 'list' ? "text-base" : "text-sm"
          )}>
            {content.title}
          </h3>
          
          <Badge variant="secondary" className="text-xs">
            {content.metadata.subject}
          </Badge>
        </div>

        {/* Description */}
        <p className="text-sm text-muted-foreground line-clamp-2">
          {content.description}
        </p>

        {/* Grade Levels */}
        <div className="flex flex-wrap gap-1">
          {content.metadata.gradeLevel.slice(0, 3).map((grade) => (
            <Badge key={grade} variant="outline" className="text-xs">
              {grade}
            </Badge>
          ))}
          {content.metadata.gradeLevel.length > 3 && (
            <Badge variant="outline" className="text-xs">
              +{content.metadata.gradeLevel.length - 3} more
            </Badge>
          )}
        </div>

        {/* Creator Info */}
        {showCreator && (
          <div className="flex items-center gap-2 text-sm text-muted-foreground">
            <Avatar className="h-6 w-6">
              <AvatarImage src={content.creator.image} />
              <AvatarFallback>
                {content.creator.name?.charAt(0).toUpperCase()}
              </AvatarFallback>
            </Avatar>
            <span>by {content.creator.name}</span>
          </div>
        )}

        {/* Rating and Stats */}
        {showRating && (
          <div className="flex items-center justify-between text-sm">
            <div className="flex items-center gap-2">
              <div className="flex items-center gap-1">
                <Star className="h-3 w-3 fill-yellow-400 text-yellow-400" />
                <span>{content.ratings.average.toFixed(1)}</span>
                <span className="text-muted-foreground">
                  ({content.ratings.count})
                </span>
              </div>
            </div>
            
            <div className="flex items-center gap-2 text-muted-foreground">
              <Eye className="h-3 w-3" />
              <span>{content.popularity.viewCount}</span>
            </div>
          </div>
        )}

        {/* Action Button */}
        <Button
          size="sm"
          className="w-full mt-3"
          onClick={(e) => {
            e.stopPropagation()
            onSelect?.(content)
          }}
        >
          View Details
        </Button>
      </div>
    </Card>
  )
}
```

### Recommendation Engine
**Content Recommendation System:**
```typescript
// lib/recommendations/engine.ts
interface UserBehavior {
  userId: string
  viewedContent: string[]
  orderedContent: string[]
  searchQueries: string[]
  preferences: {
    subjects: string[]
    gradeLevels: string[]
    priceRange: [number, number]
  }
}

export class RecommendationEngine {
  static async getRecommendations(userId: string, limit: number = 10): Promise<Content[]> {
    const userBehavior = await this.getUserBehavior(userId)
    
    // Collaborative filtering
    const collaborativeRecs = await this.getCollaborativeRecommendations(userBehavior, limit)
    
    // Content-based filtering
    const contentBasedRecs = await this.getContentBasedRecommendations(userBehavior, limit)
    
    // Trending content
    const trendingRecs = await this.getTrendingContent(limit)
    
    // Combine and score recommendations
    const combinedRecs = this.combineRecommendations([
      { recommendations: collaborativeRecs, weight: 0.4 },
      { recommendations: contentBasedRecs, weight: 0.4 },
      { recommendations: trendingRecs, weight: 0.2 }
    ])
    
    return combinedRecs.slice(0, limit)
  }

  private static async getCollaborativeRecommendations(
    userBehavior: UserBehavior, 
    limit: number
  ): Promise<Content[]> {
    // Find users with similar behavior
    const similarUsers = await User.aggregate([
      {
        $match: {
          _id: { $ne: new ObjectId(userBehavior.userId) }
        }
      },
      {
        $addFields: {
          similarity: {
            $size: {
              $setIntersection: [
                "$behavior.viewedContent",
                userBehavior.viewedContent
              ]
            }
          }
        }
      },
      { $match: { similarity: { $gt: 0 } } },
      { $sort: { similarity: -1 } },
      { $limit: 50 }
    ])

    // Get content viewed by similar users but not by current user
    const viewedByOthers = similarUsers.flatMap(user => user.behavior.viewedContent)
    const notViewedByUser = viewedByOthers.filter(
      contentId => !userBehavior.viewedContent.includes(contentId)
    )

    return Content.find({
      _id: { $in: notViewedByUser },
      status: 'approved'
    }).limit(limit)
  }

  private static async getContentBasedRecommendations(
    userBehavior: UserBehavior,
    limit: number
  ): Promise<Content[]> {
    // Get user's preferred subjects and grade levels
    const { subjects, gradeLevels } = userBehavior.preferences
    
    return Content.find({
      _id: { $nin: userBehavior.viewedContent },
      status: 'approved',
      $or: [
        { "metadata.subject": { $in: subjects } },
        { "metadata.gradeLevel": { $in: gradeLevels } }
      ]
    })
    .sort({ "ratings.average": -1, "popularity.orderCount": -1 })
    .limit(limit)
  }

  private static async getTrendingContent(limit: number): Promise<Content[]> {
    return Content.find({ status: 'approved' })
      .sort({ "popularity.trendingScore": -1 })
      .limit(limit)
  }

  private static combineRecommendations(
    weightedRecommendations: { recommendations: Content[], weight: number }[]
  ): Content[] {
    const scoredContent = new Map<string, { content: Content, score: number }>()

    weightedRecommendations.forEach(({ recommendations, weight }) => {
      recommendations.forEach((content, index) => {
        const id = content._id.toString()
        const positionScore = (recommendations.length - index) / recommendations.length
        const score = positionScore * weight

        if (scoredContent.has(id)) {
          scoredContent.get(id)!.score += score
        } else {
          scoredContent.set(id, { content, score })
        }
      })
    })

    return Array.from(scoredContent.values())
      .sort((a, b) => b.score - a.score)
      .map(item => item.content)
  }
}
```

### Mobile-Optimized Discovery
**Touch-Friendly Mobile Interface:**
```typescript
// components/content/mobile-content-browser.tsx
export function MobileContentBrowser() {
  const [activeFilter, setActiveFilter] = useState<string | null>(null)
  const [searchQuery, setSearchQuery] = useState('')
  
  return (
    <div className="md:hidden">
      {/* Mobile Search Header */}
      <div className="sticky top-0 bg-white border-b p-4 z-10">
        <div className="relative">
          <Search className="absolute left-3 top-3 h-4 w-4 text-muted-foreground" />
          <Input
            placeholder="Search materials..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="pl-10"
          />
        </div>
        
        {/* Quick Filters */}
        <div className="flex gap-2 mt-3 overflow-x-auto">
          {quickFilters.map((filter) => (
            <Button
              key={filter.id}
              variant={activeFilter === filter.id ? "default" : "outline"}
              size="sm"
              className="whitespace-nowrap"
              onClick={() => setActiveFilter(
                activeFilter === filter.id ? null : filter.id
              )}
            >
              {filter.label}
            </Button>
          ))}
        </div>
      </div>

      {/* Infinite Scroll Content Grid */}
      <div className="p-4">
        <InfiniteScrollGrid
          query={searchQuery}
          filters={{ [activeFilter]: true }}
          columns={2}
          gap={3}
          onContentSelect={handleContentSelect}
        />
      </div>
    </div>
  )
}
```

### File Locations and Project Structure
- **Discovery Pages**: `/app/browse/page.tsx`, `/app/content/[slug]/page.tsx`
- **Search Components**: `/components/content/content-search.tsx`, `/components/content/content-filters.tsx`
- **Card Components**: `/components/content/content-card.tsx`, `/components/content/content-grid.tsx`
- **API Routes**: `/app/api/content/search/`, `/app/api/content/recommendations/`, `/app/api/content/[id]/`
- **Recommendation Engine**: `/lib/recommendations/engine.ts`
- **Mobile Components**: `/components/content/mobile-content-browser.tsx`

### Environment Variables Required
```bash
# Search Configuration
SEARCH_RESULTS_PER_PAGE=20
SEARCH_CACHE_TTL=300  # 5 minutes
AUTOCOMPLETE_MIN_LENGTH=2

# Recommendations
RECOMMENDATION_ENGINE_ENABLED=true
RECOMMENDATION_CACHE_TTL=3600  # 1 hour
COLLABORATIVE_FILTERING_MIN_SIMILARITY=2

# Performance
CONTENT_IMAGE_CDN=https://cdn.yourdomain.com
SEARCH_INDEX_REBUILD_INTERVAL=86400  # 24 hours
```

## Testing

### Test Requirements
[Source: complete-architecture/testing-strategy.md#component-testing]

**Content Discovery Testing:**
```typescript
// __tests__/components/content/content-search.test.tsx
describe('ContentSearch', () => {
  it('performs search with debouncing', async () => {
    const mockSearchFn = jest.fn()
    render(<ContentSearch onResults={mockSearchFn} />)
    
    const searchInput = screen.getByPlaceholderText('Search educational materials...')
    
    // Type quickly - should debounce
    fireEvent.change(searchInput, { target: { value: 'math' } })
    fireEvent.change(searchInput, { target: { value: 'mathematics' } })
    
    // Wait for debounce
    await waitFor(() => {
      expect(mockSearchFn).toHaveBeenCalledTimes(1)
    }, { timeout: 1000 })
  })

  it('displays autocomplete suggestions', async () => {
    global.fetch = jest.fn().mockResolvedValue({
      json: () => Promise.resolve(['mathematics', 'math worksheets', 'mathematical concepts'])
    })
    
    render(<ContentSearch />)
    
    fireEvent.change(screen.getByPlaceholderText('Search educational materials...'), {
      target: { value: 'mat' }
    })
    
    await waitFor(() => {
      expect(screen.getByText('mathematics')).toBeInTheDocument()
      expect(screen.getByText('math worksheets')).toBeInTheDocument()
    })
  })
})
```

**Recommendation Engine Testing:**
```typescript
// __tests__/lib/recommendations/engine.test.ts
describe('RecommendationEngine', () => {
  it('generates collaborative filtering recommendations', async () => {
    // Mock user behavior data
    const userBehavior = {
      userId: 'user123',
      viewedContent: ['content1', 'content2'],
      preferences: {
        subjects: ['mathematics'],
        gradeLevels: ['Grade 9']
      }
    }

    const recommendations = await RecommendationEngine.getRecommendations('user123', 5)
    
    expect(recommendations).toHaveLength(5)
    expect(recommendations.every(content => content.status === 'approved')).toBe(true)
    expect(recommendations.every(content => 
      !userBehavior.viewedContent.includes(content._id.toString())
    )).toBe(true)
  })

  it('combines multiple recommendation sources with weights', () => {
    const collaborative = [mockContent1, mockContent2]
    const contentBased = [mockContent2, mockContent3]
    const trending = [mockContent3, mockContent4]

    const combined = RecommendationEngine.combineRecommendations([
      { recommendations: collaborative, weight: 0.5 },
      { recommendations: contentBased, weight: 0.3 },
      { recommendations: trending, weight: 0.2 }
    ])

    expect(combined).toBeDefined()
    expect(combined.length).toBeGreaterThan(0)
    // Content2 and Content3 should rank higher due to multiple sources
  })
})
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-16 | 1.0 | Initial story creation from Epic 2 requirements | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by development agent_

### Debug Log References
_To be populated by development agent_

### Completion Notes List
_To be populated by development agent_

### File List
_To be populated by development agent_

## QA Results
_To be populated by QA agent_