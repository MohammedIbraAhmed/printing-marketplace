# Story 3.5: Platform Administration

## Status
Draft

## Story
**As a** platform administrator,  
**I want** comprehensive administrative tools and monitoring,  
**so that** I can manage platform operations and scale effectively.

## Acceptance Criteria

1. **User Management**: Advanced admin interface for managing all user accounts with audit trails
2. **Content Administration**: Bulk content moderation tools with workflow management
3. **Platform Monitoring**: Real-time dashboards for system health, performance, and user activity
4. **Business Intelligence**: Advanced reporting on platform performance and optimization opportunities
5. **Support Tools**: Comprehensive customer support interface with ticket management and resolution tracking
6. **Configuration Management**: Admin settings for platform parameters, feature flags, and operational controls
7. **Security Administration**: User activity monitoring, security incident response, and compliance reporting

## Tasks / Subtasks

- [ ] **Task 1: Advanced User Management System** (AC: 1)
  - [ ] Build comprehensive user administration dashboard
  - [ ] Implement bulk user operations and management tools
  - [ ] Create user verification and identity management system
  - [ ] Add role-based permission management interface
  - [ ] Build user activity audit trails and investigation tools

- [ ] **Task 2: Content Moderation and Administration** (AC: 2)
  - [ ] Create bulk content moderation interface
  - [ ] Build content workflow management system
  - [ ] Implement automated content screening and flagging
  - [ ] Add copyright and intellectual property management
  - [ ] Create content creator verification and management

- [ ] **Task 3: Platform Monitoring and Health Dashboard** (AC: 3)
  - [ ] Build real-time system health monitoring
  - [ ] Create performance metrics and alerting system
  - [ ] Implement user activity and behavior monitoring
  - [ ] Add financial transaction monitoring and alerts
  - [ ] Build capacity planning and scaling insights

- [ ] **Task 4: Business Intelligence and Reporting** (AC: 4)
  - [ ] Create executive dashboard with key performance indicators
  - [ ] Build advanced analytics and trend analysis
  - [ ] Implement competitive analysis and market insights
  - [ ] Add financial reporting and revenue optimization
  - [ ] Create automated business intelligence reports

- [ ] **Task 5: Customer Support Management System** (AC: 5)
  - [ ] Build comprehensive support ticket management
  - [ ] Create customer support knowledge base and tools
  - [ ] Implement support team workflow and assignment
  - [ ] Add customer satisfaction tracking and analytics
  - [ ] Build escalation and resolution tracking system

- [ ] **Task 6: Configuration and Feature Management** (AC: 6)
  - [ ] Create platform configuration management interface
  - [ ] Build feature flag management and deployment system
  - [ ] Implement operational parameter configuration
  - [ ] Add A/B testing and experiment management
  - [ ] Create environment and deployment management tools

- [ ] **Task 7: Security and Compliance Administration** (AC: 7)
  - [ ] Build security incident monitoring and response
  - [ ] Create user activity and anomaly detection
  - [ ] Implement compliance reporting and audit tools
  - [ ] Add fraud detection and prevention systems
  - [ ] Build data privacy and GDPR compliance tools

- [ ] **Task 8: Platform Administration Testing**
  - [ ] Test admin interface functionality and performance
  - [ ] Test user management and permission systems
  - [ ] Test monitoring and alerting accuracy
  - [ ] Test security and compliance tools
  - [ ] Verify business intelligence and reporting accuracy

## Dev Notes

### Previous Story Insights
**Dependencies from Previous Stories:**
- Story 1.4: Multi-role user management foundation
- Story 3.3: Analytics system for business intelligence
- Story 3.4: Quality management and dispute resolution
- Story 2.2: Content management and moderation systems

### Admin Architecture Framework
**Comprehensive Admin Management System:**
```typescript
// lib/admin/admin-core.ts
export interface AdminUser {
  userId: string
  adminLevel: 'support' | 'moderator' | 'admin' | 'super_admin'
  permissions: AdminPermission[]
  specializations: string[] // 'content', 'financial', 'technical', 'support'
  lastActive: Date
  sessionExpiry?: Date
}

export interface AdminPermission {
  resource: string // 'users', 'content', 'orders', 'payments', 'system'
  actions: string[] // 'read', 'write', 'delete', 'approve', 'suspend'
  scope: 'all' | 'own_region' | 'assigned_only'
  restrictions?: AdminRestriction[]
}

export interface AdminRestriction {
  type: 'time_based' | 'approval_required' | 'value_limit'
  parameters: any
}

export interface AdminAction {
  id: string
  adminId: string
  action: string
  resource: string
  resourceId: string
  previousState?: any
  newState?: any
  reason?: string
  approvedBy?: string
  timestamp: Date
  ipAddress: string
  userAgent: string
}

export class AdminManager {
  static async executeAdminAction(
    adminId: string,
    action: AdminActionRequest
  ): Promise<AdminActionResult> {
    // Verify admin permissions
    const admin = await this.getAdminUser(adminId)
    if (!admin) throw new Error('Admin user not found')
    
    const hasPermission = await this.verifyPermission(admin, action)
    if (!hasPermission) throw new Error('Insufficient permissions')
    
    // Check for restrictions
    const restrictions = await this.checkRestrictions(admin, action)
    if (restrictions.blocked) {
      throw new Error(`Action blocked: ${restrictions.reason}`)
    }
    
    // Execute the action
    const result = await this.performAction(action)
    
    // Log the action
    await this.logAdminAction(adminId, action, result)
    
    // Send notifications if required
    if (action.notifyUsers) {
      await this.sendActionNotifications(action, result)
    }
    
    return result
  }
  
  static async getUserManagementInterface(
    adminId: string,
    filters: UserFilters = {}
  ): Promise<AdminUserInterface> {
    const admin = await this.getAdminUser(adminId)
    
    // Get users based on admin scope and filters
    const users = await this.getFilteredUsers(admin, filters)
    
    // Get user statistics
    const statistics = await this.getUserStatistics(admin.permissions)
    
    // Get recent actions for audit
    const recentActions = await AdminAction.find({
      resource: 'users',
      timestamp: { $gte: new Date(Date.now() - 24 * 60 * 60 * 1000) }
    }).limit(50)
    
    return {
      users,
      statistics,
      recentActions,
      permissions: admin.permissions.filter(p => p.resource === 'users'),
      bulkOperations: this.getAvailableBulkOperations(admin)
    }
  }
  
  private static async getFilteredUsers(
    admin: AdminUser,
    filters: UserFilters
  ): Promise<UserManagementView[]> {
    const query: any = {}
    
    // Apply scope restrictions
    if (admin.permissions.some(p => p.scope === 'own_region')) {
      // Add region-based filtering
      query['profile.region'] = admin.region
    }
    
    // Apply filters
    if (filters.role) query.role = filters.role
    if (filters.status) query['profile.status'] = filters.status
    if (filters.verificationStatus) query['profile.verified'] = filters.verificationStatus
    if (filters.registrationDate) {
      query.createdAt = {
        $gte: filters.registrationDate.start,
        $lte: filters.registrationDate.end
      }
    }
    
    const users = await User.find(query)
      .select('name email role profile createdAt lastLoginAt')
      .sort({ createdAt: -1 })
      .limit(filters.limit || 100)
    
    // Enhance with additional data
    return Promise.all(users.map(async (user) => ({
      ...user.toObject(),
      orderCount: await Order.countDocuments({ 'customer.userId': user._id }),
      totalSpent: await this.calculateUserSpending(user._id),
      lastActivity: await this.getLastActivity(user._id),
      riskScore: await this.calculateRiskScore(user._id),
      flags: await this.getUserFlags(user._id)
    })))
  }
  
  static async bulkUserOperation(
    adminId: string,
    operation: BulkUserOperation
  ): Promise<BulkOperationResult> {
    const admin = await this.getAdminUser(adminId)
    
    // Verify bulk operation permissions
    if (!this.canPerformBulkOperation(admin, operation.type)) {
      throw new Error('Insufficient permissions for bulk operation')
    }
    
    const results = {
      total: operation.userIds.length,
      successful: 0,
      failed: 0,
      errors: [] as string[]
    }
    
    for (const userId of operation.userIds) {
      try {
        await this.performSingleUserOperation(userId, operation, adminId)
        results.successful++
      } catch (error) {
        results.failed++
        results.errors.push(`User ${userId}: ${error.message}`)
      }
    }
    
    // Log bulk operation
    await AdminAction.create({
      adminId,
      action: `bulk_${operation.type}`,
      resource: 'users',
      resourceId: 'multiple',
      metadata: {
        userCount: operation.userIds.length,
        results
      },
      timestamp: new Date()
    })
    
    return results
  }
}
```

### Content Administration System
**Advanced Content Moderation Platform:**
```typescript
// lib/admin/content-admin.ts
export interface ContentModerationQueue {
  id: string
  contentId: string
  creatorId: string
  submittedAt: Date
  priority: 'low' | 'medium' | 'high' | 'urgent'
  status: 'pending' | 'in_review' | 'approved' | 'rejected' | 'flagged'
  assignedTo?: string
  moderationFlags: ModerationFlag[]
  aiAnalysis: AIContentAnalysis
  reviewHistory: ModerationReview[]
}

export interface ModerationFlag {
  type: 'copyright' | 'inappropriate' | 'low_quality' | 'spam' | 'educational_value'
  severity: 'low' | 'medium' | 'high'
  confidence: number
  source: 'ai' | 'user_report' | 'manual_review'
  description: string
  createdAt: Date
}

export interface AIContentAnalysis {
  copyrightRisk: number // 0-1 probability
  educationalValue: number // 0-1 score
  contentQuality: number // 0-1 score
  appropriateness: number // 0-1 score
  duplicateContent: boolean
  textAnalysis: {
    language: string
    readabilityScore: number
    grammarScore: number
    keywords: string[]
  }
  imageAnalysis?: {
    hasText: boolean
    isPhotocopied: boolean
    qualityScore: number
    inappropriateContent: boolean
  }
}

export class ContentAdministration {
  static async getModerationQueue(
    adminId: string,
    filters: ModerationFilters = {}
  ): Promise<ContentModerationQueue[]> {
    const admin = await AdminManager.getAdminUser(adminId)
    
    const query: any = {}
    
    // Apply filters
    if (filters.status) query.status = filters.status
    if (filters.priority) query.priority = filters.priority
    if (filters.assignedTo) query.assignedTo = filters.assignedTo
    if (filters.flagTypes) {
      query['moderationFlags.type'] = { $in: filters.flagTypes }
    }
    
    // Apply admin scope
    if (admin.specializations.includes('content')) {
      // Content specialist can see all
    } else {
      // Regular admin sees assigned items
      query.assignedTo = adminId
    }
    
    return ContentModerationQueue.find(query)
      .populate('contentId', 'title description file')
      .populate('creatorId', 'name email profile')
      .sort({ priority: -1, submittedAt: 1 })
      .limit(filters.limit || 50)
  }
  
  static async reviewContent(
    adminId: string,
    contentId: string,
    decision: ModerationDecision
  ): Promise<void> {
    const admin = await AdminManager.getAdminUser(adminId)
    
    // Verify permission to moderate content
    if (!AdminManager.hasPermission(admin, 'content', 'approve')) {
      throw new Error('Insufficient permissions to moderate content')
    }
    
    const queueItem = await ContentModerationQueue.findOne({ contentId })
    if (!queueItem) throw new Error('Content not found in moderation queue')
    
    // Record the review
    const review: ModerationReview = {
      reviewerId: adminId,
      decision: decision.action,
      reasoning: decision.reasoning,
      confidence: decision.confidence,
      timestamp: new Date(),
      flags: decision.flags
    }
    
    // Update queue item
    await ContentModerationQueue.findByIdAndUpdate(queueItem._id, {
      status: decision.action === 'approve' ? 'approved' : 'rejected',
      $push: { reviewHistory: review }
    })
    
    // Apply the decision
    await this.applyModerationDecision(contentId, decision)
    
    // Update content status
    const newStatus = decision.action === 'approve' ? 'approved' : 'rejected'
    await Content.findByIdAndUpdate(contentId, {
      status: newStatus,
      moderatedAt: new Date(),
      moderatedBy: adminId,
      moderationReason: decision.reasoning
    })
    
    // Notify creator
    await this.notifyCreatorOfDecision(contentId, decision)
    
    // Log admin action
    await AdminManager.logAdminAction(adminId, {
      action: 'content_moderation',
      resource: 'content',
      resourceId: contentId,
      metadata: decision
    })
  }
  
  static async bulkContentOperation(
    adminId: string,
    operation: BulkContentOperation
  ): Promise<BulkOperationResult> {
    const admin = await AdminManager.getAdminUser(adminId)
    
    // Verify bulk permissions
    if (!AdminManager.hasPermission(admin, 'content', 'bulk_operations')) {
      throw new Error('Insufficient permissions for bulk content operations')
    }
    
    const results = {
      total: operation.contentIds.length,
      successful: 0,
      failed: 0,
      errors: [] as string[]
    }
    
    for (const contentId of operation.contentIds) {
      try {
        switch (operation.action) {
          case 'approve':
            await this.reviewContent(adminId, contentId, {
              action: 'approve',
              reasoning: operation.reasoning || 'Bulk approval',
              confidence: 0.8
            })
            break
          case 'reject':
            await this.reviewContent(adminId, contentId, {
              action: 'reject',
              reasoning: operation.reasoning || 'Bulk rejection',
              confidence: 0.8
            })
            break
          case 'flag':
            await this.flagContent(contentId, operation.flagType!, operation.reasoning!)
            break
          case 'delete':
            await this.deleteContent(adminId, contentId, operation.reasoning!)
            break
        }
        results.successful++
      } catch (error) {
        results.failed++
        results.errors.push(`Content ${contentId}: ${error.message}`)
      }
    }
    
    return results
  }
  
  static async runAIContentAnalysis(contentId: string): Promise<AIContentAnalysis> {
    const content = await Content.findById(contentId)
    if (!content) throw new Error('Content not found')
    
    // Download and analyze the file
    const fileBuffer = await this.downloadContentFile(content.file.url)
    
    const analysis: AIContentAnalysis = {
      copyrightRisk: await this.analyzeCopyrightRisk(fileBuffer, content),
      educationalValue: await this.analyzeEducationalValue(content),
      contentQuality: await this.analyzeContentQuality(fileBuffer),
      appropriateness: await this.analyzeAppropriateness(content),
      duplicateContent: await this.checkDuplicateContent(fileBuffer),
      textAnalysis: await this.analyzeText(content)
    }
    
    // Add image analysis if applicable
    if (content.file.type.startsWith('image/')) {
      analysis.imageAnalysis = await this.analyzeImage(fileBuffer)
    }
    
    return analysis
  }
  
  private static async analyzeCopyrightRisk(
    fileBuffer: Buffer,
    content: Content
  ): Promise<number> {
    // Implement copyright detection logic
    // This would integrate with services like Google Vision API, AWS Rekognition
    // or custom ML models for copyright detection
    
    let riskScore = 0
    
    // Check for common copyright indicators
    const title = content.title.toLowerCase()
    const copyrightKeywords = ['official', 'textbook', 'published', 'edition', 'isbn']
    
    for (const keyword of copyrightKeywords) {
      if (title.includes(keyword)) {
        riskScore += 0.2
      }
    }
    
    // Check file metadata for publisher information
    // Check against known copyright databases
    // Analyze visual content for copyrighted material
    
    return Math.min(1, riskScore)
  }
  
  private static async analyzeEducationalValue(content: Content): Promise<number> {
    let score = 0
    
    // Analyze title and description for educational indicators
    const text = `${content.title} ${content.description}`.toLowerCase()
    const educationalKeywords = [
      'learn', 'study', 'education', 'lesson', 'practice', 'exercise',
      'worksheet', 'activity', 'curriculum', 'standard', 'objective'
    ]
    
    for (const keyword of educationalKeywords) {
      if (text.includes(keyword)) {
        score += 0.1
      }
    }
    
    // Check subject matter alignment
    if (content.metadata.subject && content.metadata.gradeLevel) {
      score += 0.3
    }
    
    // Check for learning objectives
    if (content.metadata.learningObjectives?.length > 0) {
      score += 0.2
    }
    
    return Math.min(1, score)
  }
  
  private static async checkDuplicateContent(fileBuffer: Buffer): Promise<boolean> {
    // Generate file hash
    const crypto = require('crypto')
    const hash = crypto.createHash('sha256').update(fileBuffer).digest('hex')
    
    // Check against existing content hashes
    const existingContent = await Content.findOne({
      'file.hash': hash,
      status: { $ne: 'deleted' }
    })
    
    return !!existingContent
  }
}
```

### Platform Monitoring Dashboard
**Real-time System Health and Performance:**
```typescript
// lib/admin/platform-monitoring.ts
export interface PlatformHealth {
  overall: 'healthy' | 'warning' | 'critical'
  timestamp: Date
  
  system: {
    uptime: number // seconds
    cpuUsage: number // percentage
    memoryUsage: number // percentage
    diskUsage: number // percentage
    activeConnections: number
  }
  
  database: {
    responseTime: number // milliseconds
    connectionPool: number
    activeQueries: number
    slowQueries: number
  }
  
  api: {
    requestsPerMinute: number
    averageResponseTime: number
    errorRate: number
    activeEndpoints: string[]
  }
  
  user: {
    activeUsers: number
    concurrentSessions: number
    newRegistrations: number
    conversionRate: number
  }
  
  business: {
    ordersPerMinute: number
    revenuePerHour: number
    paymentSuccessRate: number
    disputeRate: number
  }
  
  alerts: SystemAlert[]
}

export interface SystemAlert {
  id: string
  type: 'performance' | 'security' | 'business' | 'technical'
  severity: 'info' | 'warning' | 'error' | 'critical'
  title: string
  description: string
  affectedServices: string[]
  createdAt: Date
  resolvedAt?: Date
  acknowledged: boolean
  acknowledgedBy?: string
}

export class PlatformMonitoring {
  private static alertThresholds = {
    responseTime: 2000, // 2 seconds
    errorRate: 0.05, // 5%
    cpuUsage: 0.8, // 80%
    memoryUsage: 0.85, // 85%
    diskUsage: 0.9, // 90%
    slowQueryCount: 10
  }
  
  static async getCurrentHealth(): Promise<PlatformHealth> {
    const [system, database, api, user, business] = await Promise.all([
      this.getSystemMetrics(),
      this.getDatabaseMetrics(),
      this.getAPIMetrics(),
      this.getUserMetrics(),
      this.getBusinessMetrics()
    ])
    
    const alerts = await this.getActiveAlerts()
    const overall = this.calculateOverallHealth(system, database, api, alerts)
    
    return {
      overall,
      timestamp: new Date(),
      system,
      database,
      api,
      user,
      business,
      alerts
    }
  }
  
  static async monitorContinuously(): Promise<void> {
    // This would run as a background job
    setInterval(async () => {
      try {
        const health = await this.getCurrentHealth()
        
        // Check for new alerts
        await this.checkAlertConditions(health)
        
        // Store metrics for historical analysis
        await this.storeHealthMetrics(health)
        
        // Send critical alerts immediately
        const criticalAlerts = health.alerts.filter(a => a.severity === 'critical')
        for (const alert of criticalAlerts) {
          await this.sendCriticalAlert(alert)
        }
        
      } catch (error) {
        console.error('Platform monitoring error:', error)
        await this.sendMonitoringAlert(error)
      }
    }, 60000) // Every minute
  }
  
  private static async getSystemMetrics(): Promise<any> {
    const os = require('os')
    const process = require('process')
    
    return {
      uptime: process.uptime(),
      cpuUsage: await this.getCPUUsage(),
      memoryUsage: process.memoryUsage().heapUsed / process.memoryUsage().heapTotal,
      diskUsage: await this.getDiskUsage(),
      activeConnections: await this.getActiveConnections()
    }
  }
  
  private static async getDatabaseMetrics(): Promise<any> {
    const startTime = Date.now()
    
    // Test database connectivity and performance
    await mongoose.connection.db.admin().ping()
    const responseTime = Date.now() - startTime
    
    // Get connection pool info
    const connectionPool = mongoose.connection.readyState
    
    // Get slow queries (would require MongoDB profiling)
    const slowQueries = await this.getSlowQueryCount()
    
    return {
      responseTime,
      connectionPool,
      activeQueries: await this.getActiveQueryCount(),
      slowQueries
    }
  }
  
  private static async getAPIMetrics(): Promise<any> {
    // These would be collected from API middleware/monitoring service
    const metrics = await this.getAPIMetricsFromCache()
    
    return {
      requestsPerMinute: metrics.requestCount,
      averageResponseTime: metrics.avgResponseTime,
      errorRate: metrics.errorCount / metrics.requestCount,
      activeEndpoints: metrics.activeEndpoints
    }
  }
  
  private static async getUserMetrics(): Promise<any> {
    const now = new Date()
    const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000)
    const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000)
    
    const [activeUsers, newRegistrations, orders] = await Promise.all([
      this.getActiveUserCount(oneHourAgo),
      User.countDocuments({ createdAt: { $gte: oneDayAgo } }),
      Order.countDocuments({ createdAt: { $gte: oneDayAgo } })
    ])
    
    const conversionRate = newRegistrations > 0 ? orders / newRegistrations : 0
    
    return {
      activeUsers,
      concurrentSessions: await this.getConcurrentSessionCount(),
      newRegistrations,
      conversionRate
    }
  }
  
  private static async getBusinessMetrics(): Promise<any> {
    const now = new Date()
    const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000)
    
    const recentOrders = await Order.find({
      createdAt: { $gte: oneHourAgo }
    })
    
    const recentPayments = await OrderPayment.find({
      paidAt: { $gte: oneHourAgo },
      status: 'succeeded'
    })
    
    const recentDisputes = await Dispute.find({
      createdAt: { $gte: oneHourAgo }
    })
    
    return {
      ordersPerMinute: recentOrders.length / 60,
      revenuePerHour: recentPayments.reduce((sum, p) => sum + p.amount, 0),
      paymentSuccessRate: this.calculatePaymentSuccessRate(oneHourAgo),
      disputeRate: recentDisputes.length / recentOrders.length || 0
    }
  }
  
  private static async checkAlertConditions(health: PlatformHealth): Promise<void> {
    const newAlerts: SystemAlert[] = []
    
    // System alerts
    if (health.system.cpuUsage > this.alertThresholds.cpuUsage) {
      newAlerts.push({
        id: `cpu_high_${Date.now()}`,
        type: 'performance',
        severity: 'warning',
        title: 'High CPU Usage',
        description: `CPU usage at ${(health.system.cpuUsage * 100).toFixed(1)}%`,
        affectedServices: ['api', 'database'],
        createdAt: new Date(),
        acknowledged: false
      })
    }
    
    // API alerts
    if (health.api.errorRate > this.alertThresholds.errorRate) {
      newAlerts.push({
        id: `api_errors_${Date.now()}`,
        type: 'technical',
        severity: 'error',
        title: 'High API Error Rate',
        description: `API error rate at ${(health.api.errorRate * 100).toFixed(1)}%`,
        affectedServices: ['api'],
        createdAt: new Date(),
        acknowledged: false
      })
    }
    
    // Business alerts
    if (health.business.disputeRate > 0.1) {
      newAlerts.push({
        id: `disputes_high_${Date.now()}`,
        type: 'business',
        severity: 'warning',
        title: 'High Dispute Rate',
        description: `Dispute rate at ${(health.business.disputeRate * 100).toFixed(1)}%`,
        affectedServices: ['marketplace'],
        createdAt: new Date(),
        acknowledged: false
      })
    }
    
    // Save new alerts
    for (const alert of newAlerts) {
      await SystemAlert.create(alert)
    }
  }
  
  static async getPerformanceAnalytics(
    timeframe: '1h' | '24h' | '7d' | '30d'
  ): Promise<PerformanceAnalytics> {
    const dateRange = this.getDateRange(timeframe)
    
    const metrics = await PlatformMetrics.find({
      timestamp: { $gte: dateRange.start, $lte: dateRange.end }
    }).sort({ timestamp: 1 })
    
    return {
      timeframe,
      dataPoints: metrics.length,
      trends: {
        responseTime: this.calculateTrend(metrics.map(m => m.api.averageResponseTime)),
        errorRate: this.calculateTrend(metrics.map(m => m.api.errorRate)),
        throughput: this.calculateTrend(metrics.map(m => m.api.requestsPerMinute)),
        activeUsers: this.calculateTrend(metrics.map(m => m.user.activeUsers))
      },
      anomalies: await this.detectAnomalies(metrics),
      recommendations: await this.generatePerformanceRecommendations(metrics)
    }
  }
}
```

### Configuration Management System
**Feature Flags and Platform Settings:**
```typescript
// lib/admin/configuration-manager.ts
export interface PlatformConfiguration {
  id: string
  category: 'feature' | 'business' | 'technical' | 'security'
  key: string
  value: any
  type: 'boolean' | 'string' | 'number' | 'json' | 'enum'
  description: string
  
  // Deployment settings
  environment: 'development' | 'staging' | 'production'
  rolloutPercentage: number // 0-100 for gradual rollout
  targetUsers?: string[] // Specific user targeting
  
  // Change management
  createdBy: string
  createdAt: Date
  lastModifiedBy: string
  lastModifiedAt: Date
  changeReason: string
  
  // Validation and constraints
  validationRules?: ValidationRule[]
  dependencies?: string[] // Other config keys this depends on
  
  // Monitoring
  enabled: boolean
  monitored: boolean // Track usage and impact
  experimentId?: string // For A/B testing
}

export interface FeatureFlag {
  key: string
  enabled: boolean
  rolloutPercentage: number
  userSegments: string[]
  conditions: FeatureFlagCondition[]
  
  // Experiment tracking
  experimentId?: string
  trackingEvents: string[]
  successMetrics: string[]
  
  // Lifecycle
  startDate?: Date
  endDate?: Date
  status: 'draft' | 'active' | 'paused' | 'completed'
}

export interface FeatureFlagCondition {
  type: 'user_role' | 'user_property' | 'geo_location' | 'time_range' | 'custom'
  operator: 'equals' | 'not_equals' | 'in' | 'not_in' | 'greater_than' | 'less_than'
  values: any[]
}

export class ConfigurationManager {
  private static configCache = new Map<string, any>()
  private static lastCacheUpdate = 0
  private static CACHE_TTL = 60000 // 1 minute
  
  static async getConfiguration(
    key: string,
    userId?: string,
    context?: any
  ): Promise<any> {
    // Check cache first
    if (this.isCacheValid() && this.configCache.has(key)) {
      const config = this.configCache.get(key)
      
      // Apply feature flag logic if applicable
      if (config.type === 'feature' && userId) {
        return this.evaluateFeatureFlag(config, userId, context)
      }
      
      return config.value
    }
    
    // Fetch from database
    const config = await PlatformConfiguration.findOne({
      key,
      environment: process.env.NODE_ENV,
      enabled: true
    })
    
    if (!config) {
      return this.getDefaultValue(key)
    }
    
    // Cache the result
    this.configCache.set(key, config)
    
    // Apply feature flag logic
    if (config.category === 'feature' && userId) {
      return this.evaluateFeatureFlag(config, userId, context)
    }
    
    return config.value
  }
  
  static async updateConfiguration(
    adminId: string,
    key: string,
    newValue: any,
    reason: string
  ): Promise<void> {
    const admin = await AdminManager.getAdminUser(adminId)
    
    // Verify permission to modify configuration
    if (!AdminManager.hasPermission(admin, 'system', 'configure')) {
      throw new Error('Insufficient permissions to modify configuration')
    }
    
    const existingConfig = await PlatformConfiguration.findOne({ key })
    
    // Validate the new value
    if (existingConfig?.validationRules) {
      await this.validateConfigValue(newValue, existingConfig.validationRules)
    }
    
    // Check dependencies
    if (existingConfig?.dependencies) {
      await this.validateDependencies(existingConfig.dependencies, newValue)
    }
    
    // Create backup of current configuration
    if (existingConfig) {
      await this.createConfigBackup(existingConfig)
    }
    
    // Update configuration
    await PlatformConfiguration.findOneAndUpdate(
      { key },
      {
        value: newValue,
        lastModifiedBy: adminId,
        lastModifiedAt: new Date(),
        changeReason: reason
      },
      { upsert: true }
    )
    
    // Clear cache
    this.configCache.delete(key)
    
    // Log the change
    await AdminManager.logAdminAction(adminId, {
      action: 'configuration_update',
      resource: 'system',
      resourceId: key,
      previousState: existingConfig?.value,
      newState: newValue,
      reason
    })
    
    // Notify dependent services if needed
    await this.notifyConfigurationChange(key, newValue)
  }
  
  static async createFeatureFlag(
    adminId: string,
    flagData: Partial<FeatureFlag>
  ): Promise<FeatureFlag> {
    const admin = await AdminManager.getAdminUser(adminId)
    
    if (!AdminManager.hasPermission(admin, 'system', 'feature_flags')) {
      throw new Error('Insufficient permissions to create feature flags')
    }
    
    // Create the feature flag as a configuration
    const config = await PlatformConfiguration.create({
      category: 'feature',
      key: flagData.key!,
      value: flagData.enabled,
      type: 'boolean',
      description: `Feature flag: ${flagData.key}`,
      environment: process.env.NODE_ENV,
      rolloutPercentage: flagData.rolloutPercentage || 0,
      createdBy: adminId,
      createdAt: new Date(),
      lastModifiedBy: adminId,
      lastModifiedAt: new Date(),
      changeReason: 'Feature flag creation',
      enabled: true,
      monitored: true
    })
    
    // Create detailed feature flag record
    const featureFlag = await FeatureFlag.create({
      ...flagData,
      status: 'draft',
      createdBy: adminId,
      createdAt: new Date()
    })
    
    return featureFlag
  }
  
  private static async evaluateFeatureFlag(
    config: PlatformConfiguration,
    userId: string,
    context: any = {}
  ): Promise<boolean> {
    const featureFlag = await FeatureFlag.findOne({ key: config.key })
    if (!featureFlag || featureFlag.status !== 'active') {
      return false
    }
    
    // Check rollout percentage
    if (featureFlag.rolloutPercentage < 100) {
      const userHash = this.hashUserId(userId)
      const userPercentile = userHash % 100
      
      if (userPercentile >= featureFlag.rolloutPercentage) {
        return false
      }
    }
    
    // Evaluate conditions
    for (const condition of featureFlag.conditions) {
      if (!await this.evaluateCondition(condition, userId, context)) {
        return false
      }
    }
    
    // Track the flag evaluation for analytics
    await this.trackFeatureFlagUsage(config.key, userId, true)
    
    return featureFlag.enabled
  }
  
  private static async evaluateCondition(
    condition: FeatureFlagCondition,
    userId: string,
    context: any
  ): Promise<boolean> {
    let actualValue: any
    
    switch (condition.type) {
      case 'user_role':
        const user = await User.findById(userId)
        actualValue = user?.role
        break
      case 'user_property':
        const userWithProperty = await User.findById(userId)
        actualValue = this.getNestedProperty(userWithProperty, condition.property)
        break
      case 'geo_location':
        actualValue = context.country || context.region
        break
      case 'time_range':
        actualValue = new Date()
        break
      case 'custom':
        actualValue = context[condition.property]
        break
    }
    
    return this.evaluateOperator(condition.operator, actualValue, condition.values)
  }
  
  static async getFeatureFlagAnalytics(
    flagKey: string,
    timeframe: '24h' | '7d' | '30d'
  ): Promise<FeatureFlagAnalytics> {
    const dateRange = this.getDateRange(timeframe)
    
    const usageData = await FeatureFlagUsage.find({
      flagKey,
      timestamp: { $gte: dateRange.start, $lte: dateRange.end }
    })
    
    const totalEvaluations = usageData.length
    const enabledEvaluations = usageData.filter(u => u.enabled).length
    const uniqueUsers = new Set(usageData.map(u => u.userId)).size
    
    // Get conversion metrics if this is an experiment
    const conversionMetrics = await this.getConversionMetrics(flagKey, dateRange)
    
    return {
      flagKey,
      timeframe,
      totalEvaluations,
      enabledEvaluations,
      rolloutRate: enabledEvaluations / totalEvaluations,
      uniqueUsers,
      conversionMetrics,
      userSegmentBreakdown: await this.getUserSegmentBreakdown(usageData),
      performanceImpact: await this.getPerformanceImpact(flagKey, dateRange)
    }
  }
  
  static async rollbackConfiguration(
    adminId: string,
    key: string,
    reason: string
  ): Promise<void> {
    const admin = await AdminManager.getAdminUser(adminId)
    
    if (!AdminManager.hasPermission(admin, 'system', 'configure')) {
      throw new Error('Insufficient permissions to rollback configuration')
    }
    
    // Get the most recent backup
    const backup = await ConfigurationBackup.findOne({
      key,
      createdAt: { $lt: new Date() }
    }).sort({ createdAt: -1 })
    
    if (!backup) {
      throw new Error('No backup found for rollback')
    }
    
    // Restore the configuration
    await this.updateConfiguration(adminId, key, backup.value, `Rollback: ${reason}`)
    
    // Log the rollback
    await AdminManager.logAdminAction(adminId, {
      action: 'configuration_rollback',
      resource: 'system',
      resourceId: key,
      metadata: {
        backupId: backup._id,
        reason
      }
    })
  }
}
```

### File Locations and Project Structure
- **Admin Pages**: `/app/admin/page.tsx`, `/app/admin/users/page.tsx`, `/app/admin/content/page.tsx`
- **Admin Components**: `/components/admin/admin-dashboard.tsx`, `/components/admin/user-management.tsx`
- **Monitoring Components**: `/components/admin/platform-health.tsx`, `/components/admin/performance-metrics.tsx`
- **Config Components**: `/components/admin/configuration-manager.tsx`, `/components/admin/feature-flags.tsx`
- **API Routes**: `/app/api/admin/`, `/app/api/monitoring/`, `/app/api/configuration/`
- **Admin Utils**: `/lib/admin/admin-core.ts`, `/lib/admin/content-admin.ts`, `/lib/admin/platform-monitoring.ts`
- **Background Jobs**: `/lib/jobs/monitoring.ts`, `/lib/jobs/admin-tasks.ts`

## Testing

### Test Requirements
**Admin System Testing:**
```typescript
// __tests__/lib/admin/admin-core.test.ts
describe('AdminManager', () => {
  it('verifies admin permissions correctly', async () => {
    const admin = await createMockAdmin({
      level: 'admin',
      permissions: [
        { resource: 'users', actions: ['read', 'write'], scope: 'all' }
      ]
    })

    const hasPermission = await AdminManager.verifyPermission(admin, {
      resource: 'users',
      action: 'write'
    })
    
    expect(hasPermission).toBe(true)
  })

  it('logs admin actions correctly', async () => {
    const adminId = 'admin123'
    const action = {
      action: 'user_suspend',
      resource: 'users',
      resourceId: 'user456',
      reason: 'Policy violation'
    }

    await AdminManager.logAdminAction(adminId, action)
    
    const loggedAction = await AdminAction.findOne({
      adminId,
      action: 'user_suspend'
    })
    
    expect(loggedAction).toBeDefined()
    expect(loggedAction.reason).toBe('Policy violation')
  })
})
```

**Configuration Management Testing:**
```typescript
// __tests__/lib/admin/configuration-manager.test.ts
describe('ConfigurationManager', () => {
  it('evaluates feature flags correctly', async () => {
    const userId = 'user123'
    const flagKey = 'new_ui_enabled'
    
    // Create feature flag with 50% rollout
    await createMockFeatureFlag({
      key: flagKey,
      enabled: true,
      rolloutPercentage: 50
    })

    const result = await ConfigurationManager.getConfiguration(flagKey, userId)
    
    expect(typeof result).toBe('boolean')
  })

  it('validates configuration dependencies', async () => {
    const config = {
      key: 'payment_enabled',
      value: true,
      dependencies: ['stripe_configured']
    }

    // Should throw if dependency not met
    await expect(
      ConfigurationManager.updateConfiguration('admin123', config.key, true, 'test')
    ).rejects.toThrow('Dependency not satisfied')
  })
})
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-16 | 1.0 | Initial story creation from Epic 3 requirements | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by development agent_

### Debug Log References
_To be populated by development agent_

### Completion Notes List
_To be populated by development agent_

### File List
_To be populated by development agent_

## QA Results
_To be populated by QA agent_