# Story 2.7: Basic Quality Assurance

## Status
Draft

## Story
**As a** platform user,  
**I want** basic quality standards and issue resolution,  
**so that** I can trust the platform and resolve problems when they occur.

## Acceptance Criteria

1. **Quality Standards**: Basic quality metrics for print shops with rating system
2. **Issue Reporting**: Customer interface for reporting quality problems with photo upload
3. **Basic Dispute Process**: Simple workflow for handling quality complaints and resolutions
4. **Rating System**: Post-order rating and review system for both content and print quality
5. **Print Shop Monitoring**: Quality score tracking with warnings for poor performance
6. **Admin Oversight**: Basic admin tools for reviewing and resolving customer complaints
7. **Resolution Tracking**: Simple tracking of issue types and resolution outcomes

## Tasks / Subtasks

- [ ] **Task 1: Quality Standards Framework** (AC: 1)
  - [ ] Define quality metrics and scoring system for print shops
  - [ ] Create quality badges and certification levels
  - [ ] Implement quality score calculation algorithms
  - [ ] Build quality standards documentation for shops
  - [ ] Create quality improvement recommendations system

- [ ] **Task 2: Customer Issue Reporting System** (AC: 2)
  - [ ] Build comprehensive issue reporting interface
  - [ ] Implement photo upload for quality documentation
  - [ ] Create issue categorization and severity levels
  - [ ] Add issue description templates and guidance
  - [ ] Integrate with existing order communication system

- [ ] **Task 3: Dispute Resolution Workflow** (AC: 3)
  - [ ] Create basic dispute escalation process
  - [ ] Build dispute status tracking system
  - [ ] Implement resolution options (refund, reprint, credit)
  - [ ] Create dispute timeline and communication log
  - [ ] Add dispute resolution notifications

- [ ] **Task 4: Rating and Review System** (AC: 4)
  - [ ] Build post-order rating interface for customers
  - [ ] Create review submission with photos and comments
  - [ ] Implement rating aggregation and display system
  - [ ] Add review moderation and spam protection
  - [ ] Create rating analytics for shops and content

- [ ] **Task 5: Print Shop Quality Monitoring** (AC: 5)
  - [ ] Build quality dashboard for print shop owners
  - [ ] Implement quality score tracking over time
  - [ ] Create automated quality warnings and alerts
  - [ ] Add performance improvement suggestions
  - [ ] Build quality metrics reporting system

- [ ] **Task 6: Admin Quality Management Tools** (AC: 6)
  - [ ] Create admin interface for dispute review
  - [ ] Build quality standards enforcement tools
  - [ ] Implement shop performance monitoring dashboard
  - [ ] Add manual quality intervention capabilities
  - [ ] Create quality audit and compliance tracking

- [ ] **Task 7: Resolution Tracking and Analytics** (AC: 7)
  - [ ] Build resolution outcome tracking system
  - [ ] Create quality metrics and trends dashboard
  - [ ] Implement issue pattern recognition
  - [ ] Add resolution time and satisfaction tracking
  - [ ] Create quality improvement reporting

- [ ] **Task 8: Quality Assurance Testing**
  - [ ] Test issue reporting and photo upload
  - [ ] Test dispute resolution workflow
  - [ ] Test rating and review functionality
  - [ ] Test quality monitoring and alerts
  - [ ] Verify admin oversight capabilities

## Dev Notes

### Previous Story Insights
**Dependencies from Previous Stories:**
- Story 2.4: Order creation system and structure
- Story 2.5: Order management and shop operations
- Story 2.6: Issue reporting foundation and communication
- Story 1.5: Email notification system for alerts

### Quality Standards Framework
**Quality Metrics System:**
```typescript
// lib/quality/standards.ts
export interface QualityMetrics {
  printShopId: string
  overall: number              // 1-5 stars
  breakdown: {
    printQuality: number       // Technical print quality
    timeliness: number         // On-time delivery rate
    communication: number     // Response and updates
    accuracy: number          // Order specification accuracy
    customerService: number   // Overall service quality
  }
  statistics: {
    totalOrders: number
    totalReviews: number
    issueRate: number         // Percentage of orders with issues
    resolutionTime: number    // Average issue resolution hours
    repeatCustomers: number   // Customer retention rate
  }
  badges: QualityBadge[]
  lastUpdated: Date
}

export const QUALITY_STANDARDS = {
  badges: {
    excellent: { threshold: 4.8, label: 'Excellence Award', color: 'gold' },
    reliable: { threshold: 4.5, label: 'Reliable Partner', color: 'blue' },
    fastDelivery: { threshold: 4.0, label: 'Fast Delivery', color: 'green' },
    qualityPrint: { threshold: 4.5, label: 'Quality Print', color: 'purple' }
  },
  warnings: {
    lowRating: { threshold: 3.0, message: 'Low customer satisfaction detected' },
    highIssueRate: { threshold: 0.15, message: 'High issue rate requires attention' },
    slowResolution: { threshold: 48, message: 'Issue resolution time too slow' }
  }
}

export class QualityManager {
  static async calculateShopQuality(shopId: string): Promise<QualityMetrics> {
    const orders = await Order.find({ 'printShop.shopId': shopId })
    const reviews = await Review.find({ shopId })
    const issues = await OrderIssue.find({ shopId })

    // Calculate breakdown scores
    const breakdown = {
      printQuality: this.calculateAverageRating(reviews, 'printQuality'),
      timeliness: this.calculateTimelinessScore(orders),
      communication: this.calculateAverageRating(reviews, 'communication'),
      accuracy: this.calculateAccuracyScore(orders, issues),
      customerService: this.calculateAverageRating(reviews, 'customerService')
    }

    // Calculate overall score (weighted average)
    const overall = (
      breakdown.printQuality * 0.3 +
      breakdown.timeliness * 0.2 +
      breakdown.communication * 0.2 +
      breakdown.accuracy * 0.15 +
      breakdown.customerService * 0.15
    )

    const statistics = {
      totalOrders: orders.length,
      totalReviews: reviews.length,
      issueRate: issues.length / orders.length,
      resolutionTime: this.calculateAverageResolutionTime(issues),
      repeatCustomers: this.calculateRepeatCustomerRate(orders)
    }

    const badges = this.calculateEarnedBadges(breakdown, statistics)

    return {
      printShopId: shopId,
      overall,
      breakdown,
      statistics,
      badges,
      lastUpdated: new Date()
    }
  }

  private static calculateTimelinessScore(orders: Order[]): number {
    const completedOrders = orders.filter(o => o.status === 'completed')
    if (completedOrders.length === 0) return 5 // Default high score for new shops

    const onTimeOrders = completedOrders.filter(order => {
      const estimated = new Date(order.printShop.estimatedCompletion)
      const actual = new Date(order.printShop.actualCompletion || order.updatedAt)
      return actual <= estimated
    })

    const onTimeRate = onTimeOrders.length / completedOrders.length
    return Math.min(5, 1 + (onTimeRate * 4)) // Scale to 1-5
  }

  private static calculateAccuracyScore(orders: Order[], issues: OrderIssue[]): number {
    const specificationIssues = issues.filter(issue => 
      issue.type === 'wrong_specifications' || issue.type === 'incomplete_order'
    )
    
    const accuracyRate = 1 - (specificationIssues.length / orders.length)
    return Math.min(5, 1 + (accuracyRate * 4))
  }
}
```

### Issue Reporting Enhancement
**Enhanced Issue Reporting System:**
```typescript
// components/quality/issue-reporting-form.tsx
interface IssueReportingFormProps {
  order: Order
  onIssueSubmitted: (issue: OrderIssue) => void
}

export function IssueReportingForm({ order, onIssueSubmitted }: IssueReportingFormProps) {
  const [issueData, setIssueData] = useState<Partial<OrderIssue>>({
    type: '',
    severity: 'medium',
    description: '',
    photos: [],
    requestedResolution: ''
  })

  const issueTypes = [
    {
      value: 'print_quality',
      label: 'Print Quality',
      description: 'Blurry, faded, streaks, or other print defects',
      severity: ['low', 'medium', 'high'],
      resolutions: ['reprint', 'partial_refund', 'full_refund']
    },
    {
      value: 'wrong_specifications',
      label: 'Wrong Specifications',
      description: 'Incorrect paper size, color, binding, or other specs',
      severity: ['medium', 'high'],
      resolutions: ['reprint', 'full_refund']
    },
    {
      value: 'incomplete_order',
      label: 'Incomplete Order',
      description: 'Missing pages, items, or parts of the order',
      severity: ['high'],
      resolutions: ['complete_order', 'partial_refund', 'full_refund']
    },
    {
      value: 'damaged_product',
      label: 'Damaged Product',
      description: 'Physical damage, tears, stains, or other damage',
      severity: ['low', 'medium', 'high'],
      resolutions: ['reprint', 'partial_refund', 'full_refund']
    },
    {
      value: 'late_delivery',
      label: 'Late Delivery',
      description: 'Order completed significantly after promised time',
      severity: ['low', 'medium'],
      resolutions: ['discount', 'partial_refund', 'service_credit']
    },
    {
      value: 'poor_communication',
      label: 'Poor Communication',
      description: 'Unresponsive or unhelpful customer service',
      severity: ['low', 'medium'],
      resolutions: ['apology', 'service_credit', 'escalation']
    }
  ]

  const selectedIssueType = issueTypes.find(type => type.value === issueData.type)

  const handlePhotoUpload = (files: FileList) => {
    const newPhotos = Array.from(files).map(file => ({
      file,
      preview: URL.createObjectURL(file),
      uploaded: false
    }))
    setIssueData(prev => ({
      ...prev,
      photos: [...(prev.photos || []), ...newPhotos]
    }))
  }

  const handleSubmitIssue = async () => {
    try {
      // Upload photos first
      const uploadedPhotos = await Promise.all(
        (issueData.photos || []).map(async (photo) => {
          if (photo.uploaded) return photo.url
          
          const formData = new FormData()
          formData.append('file', photo.file)
          formData.append('type', 'issue-photo')
          
          const response = await fetch('/api/upload/issue-photo', {
            method: 'POST',
            body: formData
          })
          
          const { url } = await response.json()
          return url
        })
      )

      // Submit issue
      const issue = await fetch('/api/quality/report-issue', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          orderId: order._id,
          shopId: order.printShop.shopId,
          customerId: order.customer.userId,
          type: issueData.type,
          severity: issueData.severity,
          description: issueData.description,
          photos: uploadedPhotos,
          requestedResolution: issueData.requestedResolution,
          orderValue: order.pricing.total
        })
      })

      const createdIssue = await issue.json()
      onIssueSubmitted(createdIssue)
      
      // Send notifications
      await sendIssueNotifications(createdIssue)
      
    } catch (error) {
      console.error('Failed to submit issue:', error)
    }
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>Report Quality Issue</CardTitle>
        <CardDescription>
          Help us maintain high standards by reporting any issues with your order
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-6">
        {/* Issue Type Selection */}
        <div className="space-y-3">
          <Label className="text-base font-medium">What type of issue occurred?</Label>
          <RadioGroup
            value={issueData.type}
            onValueChange={(value) => setIssueData(prev => ({ ...prev, type: value }))}
          >
            {issueTypes.map((type) => (
              <div key={type.value} className="flex items-start space-x-3 p-4 border rounded-lg hover:bg-gray-50">
                <RadioGroupItem value={type.value} id={type.value} className="mt-1" />
                <div className="flex-1">
                  <Label htmlFor={type.value} className="font-medium cursor-pointer">
                    {type.label}
                  </Label>
                  <p className="text-sm text-muted-foreground mt-1">
                    {type.description}
                  </p>
                </div>
              </div>
            ))}
          </RadioGroup>
        </div>

        {/* Severity Selection */}
        {selectedIssueType && (
          <div className="space-y-2">
            <Label className="text-base font-medium">How severe is this issue?</Label>
            <RadioGroup
              value={issueData.severity}
              onValueChange={(value) => setIssueData(prev => ({ ...prev, severity: value }))}
              className="flex gap-6"
            >
              {selectedIssueType.severity.map((severity) => (
                <div key={severity} className="flex items-center space-x-2">
                  <RadioGroupItem value={severity} id={severity} />
                  <Label htmlFor={severity} className="capitalize">
                    {severity}
                    {severity === 'low' && ' - Minor inconvenience'}
                    {severity === 'medium' && ' - Noticeable problem'}
                    {severity === 'high' && ' - Major issue'}
                  </Label>
                </div>
              ))}
            </RadioGroup>
          </div>
        )}

        {/* Description */}
        <div className="space-y-2">
          <Label htmlFor="description" className="text-base font-medium">
            Describe the issue in detail
          </Label>
          <Textarea
            id="description"
            value={issueData.description}
            onChange={(e) => setIssueData(prev => ({ ...prev, description: e.target.value }))}
            placeholder="Please provide as much detail as possible about what went wrong..."
            className="min-h-[120px]"
          />
        </div>

        {/* Photo Upload */}
        <div className="space-y-3">
          <Label className="text-base font-medium">Photos (highly recommended)</Label>
          <PhotoUploadZone onPhotosAdded={handlePhotoUpload} />
          
          {issueData.photos && issueData.photos.length > 0 && (
            <div className="grid grid-cols-2 md:grid-cols-4 gap-3">
              {issueData.photos.map((photo, index) => (
                <div key={index} className="relative group">
                  <img
                    src={photo.preview}
                    alt={`Issue photo ${index + 1}`}
                    className="w-full h-24 object-cover rounded border"
                  />
                  <button
                    onClick={() => setIssueData(prev => ({
                      ...prev,
                      photos: prev.photos?.filter((_, i) => i !== index)
                    }))}
                    className="absolute top-1 right-1 w-6 h-6 bg-red-500 text-white rounded-full opacity-0 group-hover:opacity-100 transition-opacity"
                  >
                    ×
                  </button>
                </div>
              ))}
            </div>
          )}
        </div>

        {/* Requested Resolution */}
        {selectedIssueType && (
          <div className="space-y-2">
            <Label className="text-base font-medium">What resolution would you prefer?</Label>
            <Select
              value={issueData.requestedResolution}
              onValueChange={(value) => setIssueData(prev => ({ ...prev, requestedResolution: value }))}
            >
              <SelectTrigger>
                <SelectValue placeholder="Select preferred resolution" />
              </SelectTrigger>
              <SelectContent>
                {selectedIssueType.resolutions.map((resolution) => (
                  <SelectItem key={resolution} value={resolution}>
                    {resolution.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase())}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        )}

        {/* Submit Button */}
        <Button
          onClick={handleSubmitIssue}
          disabled={!issueData.type || !issueData.description}
          className="w-full"
          size="lg"
        >
          Submit Issue Report
        </Button>
      </CardContent>
    </Card>
  )
}
```

### Rating and Review System
**Comprehensive Review Interface:**
```typescript
// components/quality/order-review-form.tsx
export function OrderReviewForm({ order, onReviewSubmitted }: OrderReviewFormProps) {
  const [review, setReview] = useState<OrderReview>({
    orderId: order._id,
    shopId: order.printShop.shopId,
    customerId: order.customer.userId,
    ratings: {
      overall: 0,
      printQuality: 0,
      timeliness: 0,
      communication: 0,
      accuracy: 0,
      customerService: 0
    },
    comment: '',
    photos: [],
    wouldRecommend: true,
    contentRatings: [] // For rating individual content items
  })

  const ratingCategories = [
    {
      key: 'overall',
      label: 'Overall Experience',
      description: 'How satisfied are you overall?',
      required: true
    },
    {
      key: 'printQuality',
      label: 'Print Quality',
      description: 'How was the quality of the printed materials?',
      required: true
    },
    {
      key: 'timeliness',
      label: 'Timeliness',
      description: 'Was your order completed on time?',
      required: true
    },
    {
      key: 'communication',
      label: 'Communication',
      description: 'How well did the shop communicate with you?',
      required: false
    },
    {
      key: 'accuracy',
      label: 'Order Accuracy',
      description: 'Did you receive exactly what you ordered?',
      required: true
    },
    {
      key: 'customerService',
      label: 'Customer Service',
      description: 'How helpful and professional was the service?',
      required: false
    }
  ]

  return (
    <Card>
      <CardHeader>
        <CardTitle>Rate Your Experience</CardTitle>
        <CardDescription>
          Help other customers by sharing your experience with {order.printShop.businessInfo.name}
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-6">
        {/* Rating Categories */}
        {ratingCategories.map((category) => (
          <div key={category.key} className="space-y-2">
            <div className="flex justify-between items-center">
              <div>
                <Label className="font-medium">{category.label}</Label>
                {category.required && <span className="text-red-500 ml-1">*</span>}
                <p className="text-sm text-muted-foreground">{category.description}</p>
              </div>
              <StarRating
                value={review.ratings[category.key]}
                onChange={(value) => setReview(prev => ({
                  ...prev,
                  ratings: { ...prev.ratings, [category.key]: value }
                }))}
                size="lg"
              />
            </div>
          </div>
        ))}

        {/* Content Item Ratings */}
        {order.items.filter(item => item.contentId).length > 0 && (
          <div className="space-y-4">
            <h4 className="font-medium">Rate the Educational Content</h4>
            {order.items.filter(item => item.contentId).map((item, index) => (
              <div key={index} className="p-4 border rounded-lg space-y-3">
                <div className="flex justify-between items-start">
                  <div>
                    <h5 className="font-medium">{item.fileName}</h5>
                    <p className="text-sm text-muted-foreground">by {item.creator?.name}</p>
                  </div>
                  <StarRating
                    value={review.contentRatings[index]?.rating || 0}
                    onChange={(value) => {
                      const newContentRatings = [...review.contentRatings]
                      newContentRatings[index] = {
                        contentId: item.contentId!,
                        rating: value,
                        comment: newContentRatings[index]?.comment || ''
                      }
                      setReview(prev => ({ ...prev, contentRatings: newContentRatings }))
                    }}
                  />
                </div>
                <Textarea
                  placeholder="What did you think of this content? (optional)"
                  value={review.contentRatings[index]?.comment || ''}
                  onChange={(e) => {
                    const newContentRatings = [...review.contentRatings]
                    newContentRatings[index] = {
                      contentId: item.contentId!,
                      rating: newContentRatings[index]?.rating || 0,
                      comment: e.target.value
                    }
                    setReview(prev => ({ ...prev, contentRatings: newContentRatings }))
                  }}
                  className="min-h-[60px]"
                />
              </div>
            ))}
          </div>
        )}

        {/* Written Review */}
        <div className="space-y-2">
          <Label className="font-medium">Written Review</Label>
          <Textarea
            value={review.comment}
            onChange={(e) => setReview(prev => ({ ...prev, comment: e.target.value }))}
            placeholder="Share details about your experience to help other customers..."
            className="min-h-[120px]"
          />
        </div>

        {/* Photo Upload */}
        <div className="space-y-2">
          <Label className="font-medium">Photos (optional)</Label>
          <p className="text-sm text-muted-foreground">
            Show the quality of your printed materials
          </p>
          <PhotoUploadZone
            onPhotosAdded={(files) => {
              const newPhotos = Array.from(files).map(file => ({
                file,
                preview: URL.createObjectURL(file)
              }))
              setReview(prev => ({ ...prev, photos: [...prev.photos, ...newPhotos] }))
            }}
          />
        </div>

        {/* Recommendation */}
        <div className="space-y-2">
          <Label className="font-medium">Would you recommend this print shop?</Label>
          <RadioGroup
            value={review.wouldRecommend ? 'yes' : 'no'}
            onValueChange={(value) => setReview(prev => ({ ...prev, wouldRecommend: value === 'yes' }))}
            className="flex gap-6"
          >
            <div className="flex items-center space-x-2">
              <RadioGroupItem value="yes" id="recommend-yes" />
              <Label htmlFor="recommend-yes">Yes, I would recommend</Label>
            </div>
            <div className="flex items-center space-x-2">
              <RadioGroupItem value="no" id="recommend-no" />
              <Label htmlFor="recommend-no">No, I would not recommend</Label>
            </div>
          </RadioGroup>
        </div>

        {/* Submit Button */}
        <Button
          onClick={() => handleSubmitReview(review)}
          disabled={!review.ratings.overall || !review.ratings.printQuality}
          className="w-full"
          size="lg"
        >
          Submit Review
        </Button>
      </CardContent>
    </Card>
  )
}
```

### Admin Quality Management
**Admin Quality Dashboard:**
```typescript
// components/admin/quality-management.tsx
export function QualityManagementDashboard() {
  const [qualityData, setQualityData] = useState<QualityOverview | null>(null)
  const [selectedShop, setSelectedShop] = useState<string | null>(null)
  const [qualityIssues, setQualityIssues] = useState<QualityIssue[]>([])

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h2 className="text-2xl font-bold">Quality Management</h2>
        <div className="flex gap-2">
          <Button variant="outline">Export Report</Button>
          <Button>Quality Standards</Button>
        </div>
      </div>

      {/* Quality Overview Cards */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <QualityMetricCard
          title="Platform Average"
          value={`${qualityData?.platformAverage.toFixed(1)} ★`}
          change={qualityData?.averageChange}
          icon={Star}
        />
        <QualityMetricCard
          title="Active Issues"
          value={qualityData?.activeIssues || 0}
          change={qualityData?.issueChange}
          icon={AlertTriangle}
        />
        <QualityMetricCard
          title="Resolution Time"
          value={`${qualityData?.avgResolutionTime}h`}
          change={qualityData?.resolutionTimeChange}
          icon={Clock}
        />
        <QualityMetricCard
          title="Shop Compliance"
          value={`${qualityData?.complianceRate}%`}
          change={qualityData?.complianceChange}
          icon={Shield}
        />
      </div>

      {/* Quality Issues Table */}
      <Card>
        <CardHeader>
          <CardTitle>Recent Quality Issues</CardTitle>
        </CardHeader>
        <CardContent>
          <QualityIssuesTable
            issues={qualityIssues}
            onIssueSelect={handleIssueSelect}
            onResolveIssue={handleResolveIssue}
          />
        </CardContent>
      </Card>

      {/* Shop Performance Monitoring */}
      <Card>
        <CardHeader>
          <CardTitle>Shop Performance Alerts</CardTitle>
        </CardHeader>
        <CardContent>
          <ShopPerformanceMonitor
            onShopSelect={setSelectedShop}
            onSendWarning={handleSendWarning}
          />
        </CardContent>
      </Card>
    </div>
  )
}
```

### File Locations and Project Structure
- **Quality Pages**: `/app/quality/page.tsx`, `/app/admin/quality/page.tsx`
- **Quality Components**: `/components/quality/issue-reporting-form.tsx`, `/components/quality/order-review-form.tsx`
- **Admin Tools**: `/components/admin/quality-management.tsx`
- **API Routes**: `/app/api/quality/`, `/app/api/quality/report-issue/`, `/app/api/quality/reviews/`
- **Quality Utils**: `/lib/quality/standards.ts`, `/lib/quality/metrics.ts`

## Testing

### Test Requirements
**Quality Assurance Testing:**
```typescript
// __tests__/lib/quality/standards.test.ts
describe('QualityManager', () => {
  it('calculates shop quality metrics correctly', async () => {
    const mockOrders = [
      { status: 'completed', printShop: { estimatedCompletion: new Date(), actualCompletion: new Date() } }
    ]
    const mockReviews = [
      { ratings: { printQuality: 5, timeliness: 4 } }
    ]

    const quality = await QualityManager.calculateShopQuality('shop123')
    
    expect(quality.overall).toBeGreaterThan(0)
    expect(quality.breakdown.printQuality).toBeDefined()
    expect(quality.statistics.totalOrders).toBe(mockOrders.length)
  })

  it('awards quality badges based on performance', () => {
    const breakdown = { printQuality: 4.8, timeliness: 4.6, communication: 4.5, accuracy: 4.7, customerService: 4.5 }
    const statistics = { issueRate: 0.05, resolutionTime: 12 }
    
    const badges = QualityManager.calculateEarnedBadges(breakdown, statistics)
    
    expect(badges).toContain(expect.objectContaining({ label: 'Excellence Award' }))
  })
})
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-16 | 1.0 | Initial story creation from Epic 2 requirements | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by development agent_

### Debug Log References
_To be populated by development agent_

### Completion Notes List
_To be populated by development agent_

### File List
_To be populated by development agent_

## QA Results
_To be populated by QA agent_