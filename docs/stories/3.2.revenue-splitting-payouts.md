# Story 3.2: Revenue Splitting & Payouts

## Status
Draft

## Story
**As a** platform stakeholder,  
**I want** automatic revenue distribution and payout management,  
**so that** all parties are compensated appropriately and transparently.

## Acceptance Criteria

1. **Revenue Splitting Logic**: Automatic distribution (platform 15-20%, creator royalty, print shop payment)
2. **Escrow System**: Hold payments until order completion with automatic release triggers
3. **Payout Scheduling**: Automated weekly/monthly payouts to creators and print shops
4. **Payout Management**: Manual override capabilities and dispute resolution for payouts
5. **Tax Reporting**: Generate 1099 forms and tax reporting for creators and print shops
6. **Financial Reconciliation**: Automated matching of transactions with bank settlements
7. **Accounting Integration**: Export capabilities for external accounting systems and tax preparation

## Tasks / Subtasks

- [ ] **Task 1: Revenue Distribution Engine** (AC: 1)
  - [ ] Build configurable revenue splitting rules
  - [ ] Implement automatic percentage calculations
  - [ ] Create revenue distribution audit trail
  - [ ] Add platform fee configuration management
  - [ ] Build revenue split testing and validation

- [ ] **Task 2: Escrow Management System** (AC: 2)
  - [ ] Implement payment holding until order completion
  - [ ] Create automatic release triggers based on order status
  - [ ] Build escrow dispute and hold capabilities
  - [ ] Add manual escrow release for special cases
  - [ ] Create escrow balance tracking and reporting

- [ ] **Task 3: Automated Payout System** (AC: 3)
  - [ ] Build automated weekly/monthly payout schedules
  - [ ] Implement minimum payout thresholds
  - [ ] Create payout batch processing system
  - [ ] Add payout failure handling and retry logic
  - [ ] Build payout notification system

- [ ] **Task 4: Payout Management Interface** (AC: 4)
  - [ ] Create admin payout management dashboard
  - [ ] Build manual payout override capabilities
  - [ ] Implement payout dispute resolution workflow
  - [ ] Add payout scheduling configuration
  - [ ] Create payout history and audit logs

- [ ] **Task 5: Tax Reporting and Compliance** (AC: 5)
  - [ ] Implement 1099 form generation for US recipients
  - [ ] Create tax year reporting summaries
  - [ ] Build tax withholding calculation system
  - [ ] Add international tax compliance handling
  - [ ] Create tax document delivery system

- [ ] **Task 6: Financial Reconciliation System** (AC: 6)
  - [ ] Build automated bank settlement matching
  - [ ] Create transaction reconciliation reports
  - [ ] Implement discrepancy detection and alerts
  - [ ] Add manual reconciliation tools for admins
  - [ ] Build financial audit trail system

- [ ] **Task 7: Accounting System Integration** (AC: 7)
  - [ ] Create QuickBooks/Xero export functionality
  - [ ] Build CSV/Excel export for financial data
  - [ ] Implement accounting journal entry generation
  - [ ] Add chart of accounts mapping
  - [ ] Create automated bookkeeping sync

- [ ] **Task 8: Revenue and Payout Testing**
  - [ ] Test revenue splitting calculations accuracy
  - [ ] Test escrow hold and release mechanisms
  - [ ] Test automated payout processing
  - [ ] Test tax reporting generation
  - [ ] Verify accounting system integrations

## Dev Notes

### Previous Story Insights
**Dependencies from Previous Stories:**
- Story 3.1: Payment system integration with Stripe Connect
- Story 1.1: User and order schemas with financial tracking
- Story 2.4: Order creation system requiring revenue calculations
- Story 2.5: Order status management triggering payout releases

### Revenue Distribution Architecture
**Advanced Revenue Management:**
```typescript
// lib/revenue/distribution-engine.ts
export interface RevenueDistributionRule {
  id: string
  name: string
  active: boolean
  platformFeePercentage: number  // 15-20%
  creatorRoyaltyPercentage: number  // Variable by content
  shopPaymentPercentage: number  // Remainder after fees
  minimumPayoutThreshold: number
  effectiveDate: Date
  expiryDate?: Date
}

export interface RevenueDistribution {
  orderId: string
  orderTotal: number
  platformFee: number
  creatorRoyalties: CreatorRoyalty[]
  shopPayment: number
  processingFees: number
  netDistribution: number
  distributionRule: string
  createdAt: Date
  releasedAt?: Date
  status: 'held' | 'released' | 'disputed'
}

export interface CreatorRoyalty {
  creatorId: string
  contentId: string
  royaltyAmount: number
  royaltyPercentage: number
  orderItemValue: number
}

export class RevenueDistributionEngine {
  private static readonly DEFAULT_PLATFORM_FEE = 0.18 // 18%
  private static readonly DEFAULT_CREATOR_ROYALTY = 0.40 // 40% of content value
  
  static async calculateDistribution(
    order: Order,
    distributionRule?: RevenueDistributionRule
  ): Promise<RevenueDistribution> {
    const rule = distributionRule || await this.getActiveDistributionRule()
    
    const platformFee = order.pricing.total * rule.platformFeePercentage
    const processingFees = await this.calculateProcessingFees(order)
    
    // Calculate creator royalties for each content item
    const creatorRoyalties: CreatorRoyalty[] = []
    let totalRoyalties = 0
    
    for (const item of order.items) {
      if (item.contentId && item.creatorId) {
        const content = await Content.findById(item.contentId)
        const royaltyPercentage = content.pricing.royaltyPercentage || rule.creatorRoyaltyPercentage
        const royaltyAmount = item.pricing.contentCost * royaltyPercentage
        
        creatorRoyalties.push({
          creatorId: item.creatorId.toString(),
          contentId: item.contentId.toString(),
          royaltyAmount,
          royaltyPercentage,
          orderItemValue: item.pricing.contentCost
        })
        
        totalRoyalties += royaltyAmount
      }
    }
    
    // Shop payment is remainder after platform fee, royalties, and processing fees
    const shopPayment = order.pricing.total - platformFee - totalRoyalties - processingFees
    const netDistribution = order.pricing.total - processingFees
    
    return {
      orderId: order._id.toString(),
      orderTotal: order.pricing.total,
      platformFee,
      creatorRoyalties,
      shopPayment,
      processingFees,
      netDistribution,
      distributionRule: rule.id,
      status: 'held',
      createdAt: new Date()
    }
  }
  
  static async releaseDistribution(
    distributionId: string,
    releaseReason: string = 'order_completed'
  ): Promise<void> {
    const distribution = await RevenueDistribution.findById(distributionId)
    if (!distribution || distribution.status !== 'held') {
      throw new Error('Distribution not eligible for release')
    }
    
    try {
      // Release payments to all parties
      await Promise.all([
        this.processCreatorPayouts(distribution.creatorRoyalties),
        this.processShopPayout(distribution.orderId, distribution.shopPayment),
        this.recordPlatformRevenue(distribution.platformFee)
      ])
      
      // Update distribution status
      await RevenueDistribution.findByIdAndUpdate(distributionId, {
        status: 'released',
        releasedAt: new Date(),
        releaseReason
      })
      
      // Send payout notifications
      await this.sendPayoutNotifications(distribution)
      
    } catch (error) {
      console.error('Failed to release distribution:', error)
      throw new Error('Distribution release failed')
    }
  }
  
  private static async processCreatorPayouts(royalties: CreatorRoyalty[]): Promise<void> {
    for (const royalty of royalties) {
      await PayoutService.addToPendingPayouts({
        recipientId: royalty.creatorId,
        amount: royalty.royaltyAmount,
        type: 'creator_royalty',
        metadata: {
          contentId: royalty.contentId,
          royaltyPercentage: royalty.royaltyPercentage
        }
      })
    }
  }
  
  private static async processShopPayout(orderId: string, amount: number): Promise<void> {
    const order = await Order.findById(orderId)
    await PayoutService.addToPendingPayouts({
      recipientId: order.printShop.shopId.toString(),
      amount,
      type: 'shop_payment',
      metadata: {
        orderId: orderId
      }
    })
  }
  
  private static async calculateProcessingFees(order: Order): Promise<number> {
    // Stripe processing fees: 2.9% + $0.30 per transaction
    return (order.pricing.total * 0.029) + 0.30
  }
  
  private static async getActiveDistributionRule(): Promise<RevenueDistributionRule> {
    const rule = await RevenueDistributionRule.findOne({
      active: true,
      effectiveDate: { $lte: new Date() },
      $or: [
        { expiryDate: { $exists: false } },
        { expiryDate: { $gte: new Date() } }
      ]
    })
    
    if (!rule) {
      throw new Error('No active distribution rule found')
    }
    
    return rule
  }
}
```

### Escrow Management System
**Payment Holding and Release:**
```typescript
// lib/revenue/escrow-manager.ts
export interface EscrowAccount {
  orderId: string
  totalAmount: number
  heldAmount: number
  releasedAmount: number
  status: 'holding' | 'partial_release' | 'fully_released' | 'disputed'
  holdReason: string
  releaseConditions: EscrowReleaseCondition[]
  transactions: EscrowTransaction[]
  createdAt: Date
  releasedAt?: Date
  disputedAt?: Date
}

export interface EscrowReleaseCondition {
  type: 'order_completion' | 'time_elapsed' | 'manual_approval' | 'quality_approval'
  satisfied: boolean
  satisfiedAt?: Date
  metadata?: any
}

export interface EscrowTransaction {
  type: 'hold' | 'release' | 'dispute_hold'
  amount: number
  recipient?: string
  reason: string
  timestamp: Date
  processedBy: string
}

export class EscrowManager {
  static async createEscrowAccount(
    orderId: string,
    totalAmount: number,
    holdReason: string = 'awaiting_order_completion'
  ): Promise<EscrowAccount> {
    const releaseConditions: EscrowReleaseCondition[] = [
      {
        type: 'order_completion',
        satisfied: false
      },
      {
        type: 'time_elapsed',
        satisfied: false,
        metadata: { releaseAfterDays: 14 } // Auto-release after 14 days
      }
    ]
    
    const escrow = await EscrowAccount.create({
      orderId,
      totalAmount,
      heldAmount: totalAmount,
      releasedAmount: 0,
      status: 'holding',
      holdReason,
      releaseConditions,
      transactions: [{
        type: 'hold',
        amount: totalAmount,
        reason: holdReason,
        timestamp: new Date(),
        processedBy: 'system'
      }]
    })
    
    // Schedule automatic release check
    await this.scheduleReleaseCheck(escrow._id)
    
    return escrow
  }
  
  static async checkReleaseConditions(escrowId: string): Promise<boolean> {
    const escrow = await EscrowAccount.findById(escrowId)
    if (!escrow || escrow.status !== 'holding') {
      return false
    }
    
    let canRelease = false
    
    for (const condition of escrow.releaseConditions) {
      if (condition.satisfied) {
        canRelease = true
        break
      }
      
      switch (condition.type) {
        case 'order_completion':
          const order = await Order.findById(escrow.orderId)
          if (order?.status === 'completed') {
            condition.satisfied = true
            condition.satisfiedAt = new Date()
            canRelease = true
          }
          break
          
        case 'time_elapsed':
          const daysSinceCreation = Math.floor(
            (Date.now() - escrow.createdAt.getTime()) / (1000 * 60 * 60 * 24)
          )
          if (daysSinceCreation >= condition.metadata.releaseAfterDays) {
            condition.satisfied = true
            condition.satisfiedAt = new Date()
            canRelease = true
          }
          break
          
        case 'quality_approval':
          const qualityCheck = await QualityCheck.findOne({ orderId: escrow.orderId })
          if (qualityCheck?.status === 'approved') {
            condition.satisfied = true
            condition.satisfiedAt = new Date()
            canRelease = true
          }
          break
      }
    }
    
    // Update escrow with checked conditions
    await EscrowAccount.findByIdAndUpdate(escrowId, {
      releaseConditions: escrow.releaseConditions
    })
    
    if (canRelease) {
      await this.releaseEscrow(escrowId, 'conditions_met')
    }
    
    return canRelease
  }
  
  static async releaseEscrow(
    escrowId: string,
    releaseReason: string,
    releasedBy: string = 'system'
  ): Promise<void> {
    const escrow = await EscrowAccount.findById(escrowId)
    if (!escrow || escrow.heldAmount <= 0) {
      throw new Error('No funds available for release')
    }
    
    try {
      // Process the revenue distribution
      const distribution = await RevenueDistribution.findOne({ 
        orderId: escrow.orderId 
      })
      
      if (distribution) {
        await RevenueDistributionEngine.releaseDistribution(
          distribution._id,
          releaseReason
        )
      }
      
      // Update escrow status
      await EscrowAccount.findByIdAndUpdate(escrowId, {
        status: 'fully_released',
        releasedAmount: escrow.heldAmount,
        heldAmount: 0,
        releasedAt: new Date(),
        $push: {
          transactions: {
            type: 'release',
            amount: escrow.heldAmount,
            reason: releaseReason,
            timestamp: new Date(),
            processedBy: releasedBy
          }
        }
      })
      
      // Send release notifications
      await this.sendReleaseNotifications(escrow, releaseReason)
      
    } catch (error) {
      console.error('Escrow release failed:', error)
      throw new Error('Failed to release escrow funds')
    }
  }
  
  static async disputeEscrow(
    escrowId: string,
    disputeReason: string,
    disputedBy: string
  ): Promise<void> {
    await EscrowAccount.findByIdAndUpdate(escrowId, {
      status: 'disputed',
      disputedAt: new Date(),
      $push: {
        transactions: {
          type: 'dispute_hold',
          amount: 0,
          reason: `Disputed: ${disputeReason}`,
          timestamp: new Date(),
          processedBy: disputedBy
        }
      }
    })
    
    // Notify admin team of dispute
    await this.notifyAdminOfDispute(escrowId, disputeReason)
  }
  
  private static async scheduleReleaseCheck(escrowId: string): Promise<void> {
    // In production, this would integrate with a job queue like Bull or Agenda
    setTimeout(async () => {
      await this.checkReleaseConditions(escrowId)
    }, 24 * 60 * 60 * 1000) // Check daily
  }
  
  private static async sendReleaseNotifications(
    escrow: EscrowAccount,
    reason: string
  ): Promise<void> {
    const order = await Order.findById(escrow.orderId)
      .populate('customer.userId')
      .populate('printShop.shopId')
    
    if (order) {
      await Promise.all([
        sendEscrowReleaseEmail(order.customer.userId, escrow, reason),
        sendEscrowReleaseEmail(order.printShop.shopId, escrow, reason)
      ])
    }
  }
  
  private static async notifyAdminOfDispute(
    escrowId: string,
    reason: string
  ): Promise<void> {
    // Send admin notification for manual review
    await sendAdminNotificationEmail('escrow_dispute', {
      escrowId,
      disputeReason: reason,
      timestamp: new Date()
    })
  }
}
```

### Automated Payout System
**Scheduled Payout Processing:**
```typescript
// lib/revenue/payout-service.ts
export interface PendingPayout {
  recipientId: string
  amount: number
  type: 'creator_royalty' | 'shop_payment'
  currency: string
  orderId?: string
  contentId?: string
  metadata?: any
  createdAt: Date
  scheduledFor: Date
}

export interface ProcessedPayout {
  id: string
  recipientId: string
  amount: number
  type: string
  currency: string
  stripeTransferId?: string
  status: 'pending' | 'paid' | 'failed'
  failureReason?: string
  processedAt: Date
  paidAt?: Date
  retryCount: number
  nextRetryAt?: Date
}

export class PayoutService {
  private static readonly MIN_PAYOUT_THRESHOLD = 25.00 // $25 minimum
  private static readonly PAYOUT_SCHEDULE = {
    creators: 'weekly', // Every Friday
    shops: 'weekly'     // Every Friday
  }
  
  static async addToPendingPayouts(payout: Omit<PendingPayout, 'createdAt' | 'scheduledFor'>): Promise<void> {
    const scheduledFor = this.calculateNextPayoutDate(payout.type)
    
    await PendingPayout.create({
      ...payout,
      currency: 'USD',
      createdAt: new Date(),
      scheduledFor
    })
  }
  
  static async processScheduledPayouts(): Promise<void> {
    const now = new Date()
    
    // Group pending payouts by recipient
    const pendingPayouts = await PendingPayout.aggregate([
      {
        $match: {
          scheduledFor: { $lte: now }
        }
      },
      {
        $group: {
          _id: '$recipientId',
          totalAmount: { $sum: '$amount' },
          payouts: { $push: '$$ROOT' },
          type: { $first: '$type' }
        }
      },
      {
        $match: {
          totalAmount: { $gte: this.MIN_PAYOUT_THRESHOLD }
        }
      }
    ])
    
    // Process each recipient's batch payout
    for (const batch of pendingPayouts) {
      try {
        await this.processBatchPayout(batch)
      } catch (error) {
        console.error(`Failed to process payout for ${batch._id}:`, error)
        await this.handlePayoutFailure(batch, error.message)
      }
    }
  }
  
  private static async processBatchPayout(batch: any): Promise<void> {
    const recipient = await User.findById(batch._id)
    if (!recipient) {
      throw new Error('Recipient not found')
    }
    
    // Get recipient's Connect account
    const connectAccount = await ConnectAccount.findOne({ 
      userId: batch._id 
    })
    
    if (!connectAccount || !connectAccount.payoutsEnabled) {
      throw new Error('Recipient Connect account not ready for payouts')
    }
    
    // Create Stripe transfer
    const transfer = await stripe.transfers.create({
      amount: Math.round(batch.totalAmount * 100), // Convert to cents
      currency: 'usd',
      destination: connectAccount.stripeAccountId,
      metadata: {
        batch_id: `batch_${Date.now()}`,
        recipient_id: batch._id,
        payout_count: batch.payouts.length.toString()
      }
    })
    
    // Record processed payout
    const processedPayout = await ProcessedPayout.create({
      id: transfer.id,
      recipientId: batch._id,
      amount: batch.totalAmount,
      type: batch.type,
      currency: 'USD',
      stripeTransferId: transfer.id,
      status: 'pending',
      processedAt: new Date(),
      retryCount: 0
    })
    
    // Remove processed pending payouts
    await PendingPayout.deleteMany({
      _id: { $in: batch.payouts.map(p => p._id) }
    })
    
    // Send payout notification
    await this.sendPayoutNotification(recipient, processedPayout)
  }
  
  static async handlePayoutWebhook(transferEvent: Stripe.Transfer): Promise<void> {
    const transferId = transferEvent.id
    
    try {
      if (transferEvent.object === 'transfer') {
        await ProcessedPayout.findOneAndUpdate(
          { stripeTransferId: transferId },
          {
            status: 'paid',
            paidAt: new Date()
          }
        )
      }
    } catch (error) {
      console.error('Failed to handle payout webhook:', error)
    }
  }
  
  static async retryFailedPayouts(): Promise<void> {
    const failedPayouts = await ProcessedPayout.find({
      status: 'failed',
      retryCount: { $lt: 3 },
      nextRetryAt: { $lte: new Date() }
    })
    
    for (const payout of failedPayouts) {
      try {
        // Retry the transfer
        const newTransfer = await stripe.transfers.create({
          amount: Math.round(payout.amount * 100),
          currency: payout.currency.toLowerCase(),
          destination: await this.getRecipientStripeAccount(payout.recipientId),
          metadata: {
            retry_of: payout.stripeTransferId,
            retry_count: (payout.retryCount + 1).toString()
          }
        })
        
        // Update payout record
        await ProcessedPayout.findByIdAndUpdate(payout._id, {
          stripeTransferId: newTransfer.id,
          status: 'pending',
          retryCount: payout.retryCount + 1,
          $unset: { nextRetryAt: 1 }
        })
        
      } catch (error) {
        // Schedule next retry with exponential backoff
        const nextRetry = new Date(Date.now() + Math.pow(2, payout.retryCount) * 60 * 60 * 1000)
        
        await ProcessedPayout.findByIdAndUpdate(payout._id, {
          retryCount: payout.retryCount + 1,
          nextRetryAt: nextRetry,
          failureReason: error.message
        })
      }
    }
  }
  
  private static calculateNextPayoutDate(type: string): Date {
    const now = new Date()
    const dayOfWeek = now.getDay() // 0 = Sunday, 5 = Friday
    
    // Calculate next Friday
    const daysUntilFriday = (5 - dayOfWeek + 7) % 7
    const nextFriday = new Date(now)
    nextFriday.setDate(now.getDate() + (daysUntilFriday || 7))
    nextFriday.setHours(9, 0, 0, 0) // 9 AM on Friday
    
    return nextFriday
  }
  
  private static async getRecipientStripeAccount(recipientId: string): Promise<string> {
    const connectAccount = await ConnectAccount.findOne({ userId: recipientId })
    if (!connectAccount) {
      throw new Error('Connect account not found')
    }
    return connectAccount.stripeAccountId
  }
  
  private static async sendPayoutNotification(
    recipient: User,
    payout: ProcessedPayout
  ): Promise<void> {
    await sendPayoutNotificationEmail(recipient, {
      amount: payout.amount,
      type: payout.type,
      estimatedArrival: '1-2 business days',
      transferId: payout.stripeTransferId
    })
  }
  
  private static async handlePayoutFailure(batch: any, error: string): Promise<void> {
    // Log the failure
    console.error(`Payout batch failed for recipient ${batch._id}:`, error)
    
    // Notify admin
    await sendAdminNotificationEmail('payout_failure', {
      recipientId: batch._id,
      amount: batch.totalAmount,
      error,
      timestamp: new Date()
    })
    
    // Reschedule payouts for next cycle
    const nextSchedule = this.calculateNextPayoutDate(batch.type)
    await PendingPayout.updateMany(
      { _id: { $in: batch.payouts.map(p => p._id) } },
      { scheduledFor: nextSchedule }
    )
  }
}
```

### Tax Reporting System
**1099 Generation and Tax Compliance:**
```typescript
// lib/revenue/tax-reporting.ts
export interface TaxReportingProfile {
  userId: string
  taxYear: number
  taxpayerType: 'individual' | 'business'
  tinType: 'ssn' | 'ein'
  taxId: string // SSN or EIN (encrypted)
  legalName: string
  businessName?: string
  address: Address
  backupWithholding: boolean
  exemptFromBackupWithholding: boolean
  totalEarnings: number
  totalWithheld: number
  form1099Required: boolean
  form1099Generated: boolean
  form1099SentAt?: Date
}

export interface TaxDocument {
  id: string
  recipientId: string
  taxYear: number
  documentType: '1099-NEC' | '1099-MISC' | 'summary'
  earnings: {
    nonEmployeeCompensation: number // Box 1 on 1099-NEC
    miscellaneousIncome: number
    backupWithholding: number
  }
  generated: boolean
  sentToRecipient: boolean
  sentToIRS: boolean
  generatedAt?: Date
  sentAt?: Date
}

export class TaxReportingService {
  private static readonly TAX_YEAR = new Date().getFullYear()
  private static readonly REPORTING_THRESHOLD = 600 // $600 annual threshold
  
  static async generateAnnualTaxReports(taxYear: number): Promise<void> {
    // Get all users who exceeded reporting threshold
    const eligibleUsers = await this.getEligibleTaxpayers(taxYear)
    
    for (const user of eligibleUsers) {
      try {
        await this.generateUserTaxDocuments(user.userId, taxYear)
      } catch (error) {
        console.error(`Failed to generate tax documents for user ${user.userId}:`, error)
      }
    }
  }
  
  static async generateUserTaxDocuments(
    userId: string,
    taxYear: number
  ): Promise<TaxDocument[]> {
    const profile = await TaxReportingProfile.findOne({ userId, taxYear })
    if (!profile) {
      throw new Error('Tax reporting profile not found')
    }
    
    if (profile.totalEarnings < this.REPORTING_THRESHOLD) {
      return [] // Below reporting threshold
    }
    
    const earnings = await this.calculateAnnualEarnings(userId, taxYear)
    const documents: TaxDocument[] = []
    
    // Generate 1099-NEC for non-employee compensation
    if (earnings.creatorRoyalties > 0 || earnings.shopPayments > 0) {
      const form1099NEC = await this.generate1099NEC(userId, taxYear, {
        nonEmployeeCompensation: earnings.creatorRoyalties + earnings.shopPayments,
        backupWithholding: earnings.backupWithholding
      })
      documents.push(form1099NEC)
    }
    
    // Generate summary document
    const summary = await this.generateEarningsSummary(userId, taxYear, earnings)
    documents.push(summary)
    
    // Send documents to recipient
    await this.sendTaxDocuments(userId, documents)
    
    return documents
  }
  
  private static async generate1099NEC(
    userId: string,
    taxYear: number,
    earnings: { nonEmployeeCompensation: number; backupWithholding: number }
  ): Promise<TaxDocument> {
    const user = await User.findById(userId)
    const profile = await TaxReportingProfile.findOne({ userId, taxYear })
    
    const documentId = `1099NEC_${taxYear}_${userId}_${Date.now()}`
    
    // Generate PDF using a tax form service or library
    const pdfBuffer = await this.generateTaxFormPDF('1099-NEC', {
      taxYear,
      recipient: {
        name: profile.legalName,
        address: profile.address,
        taxId: await this.decryptTaxId(profile.taxId)
      },
      payer: {
        name: process.env.COMPANY_LEGAL_NAME,
        address: process.env.COMPANY_ADDRESS,
        ein: process.env.COMPANY_EIN
      },
      earnings: {
        nonEmployeeCompensation: earnings.nonEmployeeCompensation,
        backupWithholding: earnings.backupWithholding
      }
    })
    
    // Store the document
    const taxDocument = await TaxDocument.create({
      id: documentId,
      recipientId: userId,
      taxYear,
      documentType: '1099-NEC',
      earnings: {
        nonEmployeeCompensation: earnings.nonEmployeeCompensation,
        miscellaneousIncome: 0,
        backupWithholding: earnings.backupWithholding
      },
      generated: true,
      generatedAt: new Date()
    })
    
    // Upload PDF to secure storage
    await this.storeTaxDocument(documentId, pdfBuffer)
    
    return taxDocument
  }
  
  private static async calculateAnnualEarnings(
    userId: string,
    taxYear: number
  ): Promise<{
    creatorRoyalties: number
    shopPayments: number
    backupWithholding: number
    totalEarnings: number
  }> {
    const startDate = new Date(taxYear, 0, 1)
    const endDate = new Date(taxYear + 1, 0, 1)
    
    // Aggregate all processed payouts for the tax year
    const earnings = await ProcessedPayout.aggregate([
      {
        $match: {
          recipientId: userId,
          status: 'paid',
          paidAt: { $gte: startDate, $lt: endDate }
        }
      },
      {
        $group: {
          _id: '$type',
          totalAmount: { $sum: '$amount' }
        }
      }
    ])
    
    let creatorRoyalties = 0
    let shopPayments = 0
    
    earnings.forEach(earning => {
      if (earning._id === 'creator_royalty') {
        creatorRoyalties = earning.totalAmount
      } else if (earning._id === 'shop_payment') {
        shopPayments = earning.totalAmount
      }
    })
    
    // Calculate backup withholding if applicable
    const profile = await TaxReportingProfile.findOne({ userId, taxYear })
    const backupWithholding = profile?.backupWithholding 
      ? (creatorRoyalties + shopPayments) * 0.24 // 24% backup withholding rate
      : 0
    
    return {
      creatorRoyalties,
      shopPayments,
      backupWithholding,
      totalEarnings: creatorRoyalties + shopPayments
    }
  }
  
  static async updateTaxProfile(
    userId: string,
    profileData: Partial<TaxReportingProfile>
  ): Promise<void> {
    const taxYear = this.TAX_YEAR
    
    await TaxReportingProfile.findOneAndUpdate(
      { userId, taxYear },
      { 
        ...profileData,
        taxId: profileData.taxId ? await this.encryptTaxId(profileData.taxId) : undefined
      },
      { upsert: true }
    )
  }
  
  private static async getEligibleTaxpayers(taxYear: number): Promise<{ userId: string }[]> {
    return ProcessedPayout.aggregate([
      {
        $match: {
          status: 'paid',
          paidAt: {
            $gte: new Date(taxYear, 0, 1),
            $lt: new Date(taxYear + 1, 0, 1)
          }
        }
      },
      {
        $group: {
          _id: '$recipientId',
          totalEarnings: { $sum: '$amount' }
        }
      },
      {
        $match: {
          totalEarnings: { $gte: this.REPORTING_THRESHOLD }
        }
      },
      {
        $project: {
          userId: '$_id',
          _id: 0
        }
      }
    ])
  }
  
  private static async generateTaxFormPDF(
    formType: string,
    data: any
  ): Promise<Buffer> {
    // In production, use a proper PDF generation library like PDFtk or similar
    // This is a placeholder for the actual implementation
    const PDFDocument = require('pdfkit')
    
    return new Promise((resolve) => {
      const doc = new PDFDocument()
      const buffers: Buffer[] = []
      
      doc.on('data', buffers.push.bind(buffers))
      doc.on('end', () => {
        const pdfBuffer = Buffer.concat(buffers)
        resolve(pdfBuffer)
      })
      
      // Generate tax form content
      doc.fontSize(12)
      doc.text(`${formType} - Tax Year ${data.taxYear}`, 100, 100)
      doc.text(`Recipient: ${data.recipient.name}`, 100, 130)
      doc.text(`Non-Employee Compensation: $${data.earnings.nonEmployeeCompensation.toFixed(2)}`, 100, 160)
      
      doc.end()
    })
  }
  
  private static async storeTaxDocument(documentId: string, pdfBuffer: Buffer): Promise<void> {
    // Store in secure file storage with encryption
    const key = `tax-documents/${documentId}.pdf`
    await secureFileStorage.upload(key, pdfBuffer, {
      encryption: true,
      retention: '7years' // IRS retention requirement
    })
  }
  
  private static async sendTaxDocuments(
    userId: string,
    documents: TaxDocument[]
  ): Promise<void> {
    const user = await User.findById(userId)
    
    for (const document of documents) {
      await sendTaxDocumentEmail(user, {
        documentType: document.documentType,
        taxYear: document.taxYear,
        downloadUrl: await this.generateSecureDownloadUrl(document.id)
      })
      
      await TaxDocument.findByIdAndUpdate(document._id, {
        sentToRecipient: true,
        sentAt: new Date()
      })
    }
  }
  
  private static async encryptTaxId(taxId: string): Promise<string> {
    // Use proper encryption for sensitive tax data
    const crypto = require('crypto')
    const algorithm = 'aes-256-gcm'
    const key = Buffer.from(process.env.TAX_ENCRYPTION_KEY!, 'hex')
    
    const iv = crypto.randomBytes(16)
    const cipher = crypto.createCipher(algorithm, key)
    
    let encrypted = cipher.update(taxId, 'utf8', 'hex')
    encrypted += cipher.final('hex')
    
    return `${iv.toString('hex')}:${encrypted}`
  }
  
  private static async decryptTaxId(encryptedTaxId: string): Promise<string> {
    const crypto = require('crypto')
    const algorithm = 'aes-256-gcm'
    const key = Buffer.from(process.env.TAX_ENCRYPTION_KEY!, 'hex')
    
    const [ivHex, encrypted] = encryptedTaxId.split(':')
    const iv = Buffer.from(ivHex, 'hex')
    const decipher = crypto.createDecipher(algorithm, key)
    
    let decrypted = decipher.update(encrypted, 'hex', 'utf8')
    decrypted += decipher.final('utf8')
    
    return decrypted
  }
}
```

### File Locations and Project Structure
- **Revenue Pages**: `/app/admin/revenue/page.tsx`, `/app/shop/payouts/page.tsx`, `/app/creator/earnings/page.tsx`
- **Revenue Components**: `/components/revenue/distribution-dashboard.tsx`, `/components/revenue/payout-schedule.tsx`
- **Escrow Components**: `/components/revenue/escrow-status.tsx`, `/components/revenue/escrow-management.tsx`
- **Tax Components**: `/components/revenue/tax-profile.tsx`, `/components/revenue/tax-documents.tsx`
- **API Routes**: `/app/api/revenue/`, `/app/api/payouts/`, `/app/api/tax-reporting/`, `/app/api/webhooks/stripe/`
- **Revenue Utils**: `/lib/revenue/distribution-engine.ts`, `/lib/revenue/escrow-manager.ts`, `/lib/revenue/payout-service.ts`
- **Background Jobs**: `/lib/jobs/payout-processor.ts`, `/lib/jobs/tax-reporting.ts`

## Testing

### Test Requirements
**Revenue Distribution Testing:**
```typescript
// __tests__/lib/revenue/distribution-engine.test.ts
describe('RevenueDistributionEngine', () => {
  it('calculates distribution correctly', async () => {
    const order = createMockOrder({
      pricing: { total: 100 },
      items: [{ 
        contentId: 'content123', 
        creatorId: 'creator123',
        pricing: { contentCost: 30 }
      }]
    })

    const distribution = await RevenueDistributionEngine.calculateDistribution(order)
    
    expect(distribution.platformFee).toBe(18) // 18% of $100
    expect(distribution.creatorRoyalties[0].royaltyAmount).toBe(12) // 40% of $30
    expect(distribution.shopPayment).toBe(69.7) // $100 - $18 - $12 - processing fees
  })

  it('releases distribution when conditions are met', async () => {
    const distribution = await createMockDistribution()
    
    await RevenueDistributionEngine.releaseDistribution(
      distribution._id,
      'order_completed'
    )
    
    const updated = await RevenueDistribution.findById(distribution._id)
    expect(updated.status).toBe('released')
    expect(updated.releasedAt).toBeDefined()
  })
})
```

**Payout Service Testing:**
```typescript
// __tests__/lib/revenue/payout-service.test.ts
describe('PayoutService', () => {
  it('processes batch payouts correctly', async () => {
    // Create pending payouts above threshold
    await PayoutService.addToPendingPayouts({
      recipientId: 'user123',
      amount: 30,
      type: 'creator_royalty'
    })
    
    await PayoutService.processScheduledPayouts()
    
    const processedPayout = await ProcessedPayout.findOne({ 
      recipientId: 'user123' 
    })
    expect(processedPayout.status).toBe('pending')
    expect(processedPayout.amount).toBe(30)
  })

  it('skips payouts below minimum threshold', async () => {
    await PayoutService.addToPendingPayouts({
      recipientId: 'user456',
      amount: 15, // Below $25 threshold
      type: 'creator_royalty'
    })
    
    await PayoutService.processScheduledPayouts()
    
    const processedPayout = await ProcessedPayout.findOne({ 
      recipientId: 'user456' 
    })
    expect(processedPayout).toBeNull()
  })
})
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-16 | 1.0 | Initial story creation from Epic 3 requirements | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by development agent_

### Debug Log References
_To be populated by development agent_

### Completion Notes List
_To be populated by development agent_

### File List
_To be populated by development agent_

## QA Results
_To be populated by QA agent_