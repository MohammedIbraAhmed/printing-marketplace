# Story 3.4: Advanced Quality & Dispute Resolution

## Status
Draft

## Story
**As a** platform user,  
**I want** comprehensive quality assurance and fair dispute resolution,  
**so that** I can trust platform quality and resolve complex issues effectively.

## Acceptance Criteria

1. **Enhanced Quality Standards**: Comprehensive quality metrics with automated monitoring
2. **Advanced Dispute System**: Structured escalation process with evidence collection and review
3. **Automated Refunds**: Rule-based refund processing with manual override capabilities
4. **Quality Tracking**: Advanced analytics on dispute types, resolution times, and satisfaction
5. **Print Shop Performance**: Automated warnings and suspension capabilities for poor performance
6. **Mediation Tools**: Admin tools for complex dispute resolution and customer support
7. **Content Moderation**: Advanced review system with copyright compliance and appeals process

## Tasks / Subtasks

- [ ] **Task 1: Enhanced Quality Monitoring System** (AC: 1)
  - [ ] Build comprehensive quality metrics framework
  - [ ] Implement automated quality scoring algorithms
  - [ ] Create quality threshold monitoring and alerts
  - [ ] Add predictive quality issue detection
  - [ ] Build quality trend analysis and reporting

- [ ] **Task 2: Advanced Dispute Management System** (AC: 2)
  - [ ] Create structured dispute escalation workflow
  - [ ] Build evidence collection and documentation system
  - [ ] Implement dispute categorization and routing
  - [ ] Add mediation scheduling and case management
  - [ ] Create dispute resolution timeline tracking

- [ ] **Task 3: Automated Refund Processing** (AC: 3)
  - [ ] Build rule-based refund decision engine
  - [ ] Implement automatic refund approval workflows
  - [ ] Create partial refund calculation system
  - [ ] Add manual override capabilities for admins
  - [ ] Build refund audit trail and reporting

- [ ] **Task 4: Quality Analytics and Insights** (AC: 4)
  - [ ] Create comprehensive dispute analytics dashboard
  - [ ] Build quality trend analysis and forecasting
  - [ ] Implement customer satisfaction tracking
  - [ ] Add dispute resolution performance metrics
  - [ ] Create quality improvement recommendation engine

- [ ] **Task 5: Print Shop Performance Management** (AC: 5)
  - [ ] Build automated performance monitoring system
  - [ ] Create performance warning and notification system
  - [ ] Implement graduated suspension mechanisms
  - [ ] Add performance improvement plans and tracking
  - [ ] Build shop rehabilitation and reinstatement process

- [ ] **Task 6: Admin Mediation and Support Tools** (AC: 6)
  - [ ] Create comprehensive admin dispute dashboard
  - [ ] Build case management and assignment system
  - [ ] Implement communication tools for all parties
  - [ ] Add evidence review and decision support tools
  - [ ] Create escalation and appeals management

- [ ] **Task 7: Content Moderation and Copyright System** (AC: 7)
  - [ ] Build advanced content review workflow
  - [ ] Implement copyright infringement detection
  - [ ] Create DMCA compliance and takedown process
  - [ ] Add content appeals and reinstatement system
  - [ ] Build intellectual property protection tools

- [ ] **Task 8: Quality and Dispute System Testing**
  - [ ] Test quality monitoring accuracy and responsiveness
  - [ ] Test dispute escalation and resolution workflows
  - [ ] Test automated refund processing rules
  - [ ] Test admin mediation tools and interfaces
  - [ ] Verify performance monitoring and actions

## Dev Notes

### Previous Story Insights
**Dependencies from Previous Stories:**
- Story 2.7: Basic quality assurance system foundation
- Story 3.1: Payment system for refund processing
- Story 3.2: Revenue distribution affected by disputes
- Story 2.6: Order communication system for dispute management

### Enhanced Quality Framework
**Advanced Quality Monitoring System:**
```typescript
// lib/quality/advanced-monitoring.ts
export interface QualityMetrics {
  shopId: string
  period: 'daily' | 'weekly' | 'monthly'
  startDate: Date
  endDate: Date
  
  // Core quality indicators
  overall: {
    score: number          // 0-100 composite score
    trend: number         // -1 to 1, trend direction
    rank: number          // Percentile ranking among all shops
    status: 'excellent' | 'good' | 'warning' | 'critical'
  }
  
  // Detailed metrics
  metrics: {
    orderAccuracy: number      // % orders completed as specified
    timeliness: number         // % orders completed on time
    customerSatisfaction: number // Average customer rating
    issueResolution: number    // % issues resolved satisfactorily
    communicationQuality: number // Customer feedback on communication
  }
  
  // Risk indicators
  riskFactors: {
    disputeRate: number        // % orders resulting in disputes
    refundRate: number         // % orders requiring refunds
    lateCancellationRate: number // % orders cancelled after acceptance
    qualityComplaintRate: number // % orders with quality complaints
  }
  
  // Performance trends
  trends: {
    orderVolume: TrendData
    customerRetention: TrendData
    averageOrderValue: TrendData
    completionTime: TrendData
  }
  
  // Predictive indicators
  predictions: {
    riskLevel: 'low' | 'medium' | 'high'
    suspensionProbability: number
    performanceForecst: number
    recommendedActions: QualityAction[]
  }
}

export interface QualityAction {
  type: 'warning' | 'training' | 'suspension' | 'improvement_plan'
  priority: 'low' | 'medium' | 'high' | 'urgent'
  description: string
  deadline?: Date
  autoExecute: boolean
}

export class AdvancedQualityMonitor {
  private static readonly QUALITY_THRESHOLDS = {
    excellent: 90,
    good: 75,
    warning: 60,
    critical: 45
  }
  
  private static readonly RISK_WEIGHTS = {
    disputeRate: 0.25,
    refundRate: 0.20,
    customerSatisfaction: 0.20,
    timeliness: 0.15,
    orderAccuracy: 0.20
  }
  
  static async calculateQualityMetrics(
    shopId: string,
    period: 'daily' | 'weekly' | 'monthly'
  ): Promise<QualityMetrics> {
    const dateRange = this.getDateRange(period)
    
    // Get shop data for the period
    const [orders, disputes, reviews, issues] = await Promise.all([
      this.getShopOrders(shopId, dateRange),
      this.getShopDisputes(shopId, dateRange),
      this.getShopReviews(shopId, dateRange),
      this.getShopIssues(shopId, dateRange)
    ])
    
    // Calculate core metrics
    const metrics = {
      orderAccuracy: this.calculateOrderAccuracy(orders, issues),
      timeliness: this.calculateTimeliness(orders),
      customerSatisfaction: this.calculateCustomerSatisfaction(reviews),
      issueResolution: this.calculateIssueResolution(issues),
      communicationQuality: this.calculateCommunicationQuality(reviews)
    }
    
    // Calculate risk factors
    const riskFactors = {
      disputeRate: disputes.length / orders.length,
      refundRate: disputes.filter(d => d.resolution === 'refund').length / orders.length,
      lateCancellationRate: orders.filter(o => o.status === 'cancelled' && o.acceptedAt).length / orders.length,
      qualityComplaintRate: issues.filter(i => i.type.includes('quality')).length / orders.length
    }
    
    // Calculate overall score
    const overall = {
      score: this.calculateOverallScore(metrics, riskFactors),
      trend: await this.calculateTrend(shopId, period),
      rank: await this.calculatePercentileRank(shopId, metrics),
      status: this.getQualityStatus(this.calculateOverallScore(metrics, riskFactors))
    }
    
    // Generate predictions and recommendations
    const predictions = await this.generatePredictions(shopId, metrics, riskFactors)
    
    return {
      shopId,
      period,
      startDate: dateRange.start,
      endDate: dateRange.end,
      overall,
      metrics,
      riskFactors,
      trends: await this.calculateTrends(shopId, dateRange),
      predictions
    }
  }
  
  static async monitorQualityThresholds(): Promise<void> {
    const activeShops = await User.find({ role: 'printShop', 'profile.status': 'active' })
    
    for (const shop of activeShops) {
      const qualityMetrics = await this.calculateQualityMetrics(shop._id, 'weekly')
      
      // Check for threshold violations
      const violations = this.checkThresholdViolations(qualityMetrics)
      
      for (const violation of violations) {
        await this.handleQualityViolation(shop._id, violation, qualityMetrics)
      }
      
      // Execute automatic actions
      for (const action of qualityMetrics.predictions.recommendedActions) {
        if (action.autoExecute) {
          await this.executeQualityAction(shop._id, action)
        }
      }
    }
  }
  
  private static calculateOverallScore(
    metrics: any,
    riskFactors: any
  ): number {
    // Calculate positive score from metrics
    const positiveScore = (
      metrics.orderAccuracy * 0.25 +
      metrics.timeliness * 0.20 +
      metrics.customerSatisfaction * 0.20 +
      metrics.issueResolution * 0.15 +
      metrics.communicationQuality * 0.20
    ) * 100
    
    // Calculate negative impact from risk factors
    const riskPenalty = (
      riskFactors.disputeRate * 30 +
      riskFactors.refundRate * 25 +
      riskFactors.lateCancellationRate * 15 +
      riskFactors.qualityComplaintRate * 20
    ) * 100
    
    return Math.max(0, positiveScore - riskPenalty)
  }
  
  private static async generatePredictions(
    shopId: string,
    metrics: any,
    riskFactors: any
  ): Promise<any> {
    // Calculate risk level
    const riskScore = Object.values(riskFactors).reduce((sum: number, val: any) => sum + val, 0) / Object.keys(riskFactors).length
    const riskLevel = riskScore > 0.15 ? 'high' : riskScore > 0.08 ? 'medium' : 'low'
    
    // Calculate suspension probability
    const suspensionProbability = Math.min(1, riskScore * 2)
    
    // Generate recommended actions
    const recommendedActions = await this.generateRecommendedActions(metrics, riskFactors)
    
    return {
      riskLevel,
      suspensionProbability,
      performanceForecst: await this.forecastPerformance(shopId, metrics),
      recommendedActions
    }
  }
  
  private static async generateRecommendedActions(
    metrics: any,
    riskFactors: any
  ): Promise<QualityAction[]> {
    const actions: QualityAction[] = []
    
    // Quality-based actions
    if (metrics.orderAccuracy < 0.85) {
      actions.push({
        type: 'training',
        priority: 'high',
        description: 'Order accuracy training required - current rate below 85%',
        deadline: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
        autoExecute: false
      })
    }
    
    if (metrics.timeliness < 0.8) {
      actions.push({
        type: 'improvement_plan',
        priority: 'medium',
        description: 'Delivery time improvement plan needed - 20% of orders delivered late',
        deadline: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000),
        autoExecute: false
      })
    }
    
    // Risk-based actions
    if (riskFactors.disputeRate > 0.1) {
      actions.push({
        type: 'warning',
        priority: 'urgent',
        description: 'High dispute rate detected - immediate quality review required',
        autoExecute: true
      })
    }
    
    if (riskFactors.refundRate > 0.15) {
      actions.push({
        type: 'suspension',
        priority: 'urgent',
        description: 'Excessive refund rate - temporary suspension pending review',
        autoExecute: true
      })
    }
    
    return actions
  }
  
  private static async executeQualityAction(
    shopId: string,
    action: QualityAction
  ): Promise<void> {
    switch (action.type) {
      case 'warning':
        await this.sendQualityWarning(shopId, action)
        break
      case 'suspension':
        await this.suspendShop(shopId, action.description)
        break
      case 'training':
        await this.scheduleTraining(shopId, action)
        break
      case 'improvement_plan':
        await this.createImprovementPlan(shopId, action)
        break
    }
    
    // Log the action
    await QualityAction.create({
      shopId,
      type: action.type,
      description: action.description,
      executedAt: new Date(),
      autoExecuted: action.autoExecute
    })
  }
}
```

### Advanced Dispute Management
**Comprehensive Dispute Resolution System:**
```typescript
// lib/quality/dispute-manager.ts
export interface Dispute {
  id: string
  orderId: string
  customerId: string
  shopId: string
  creatorId?: string
  
  // Dispute details
  type: 'quality' | 'delivery' | 'billing' | 'service' | 'content' | 'other'
  category: DisputeCategory
  severity: 'low' | 'medium' | 'high' | 'critical'
  priority: number // 1-10 priority score
  
  // Status and workflow
  status: 'submitted' | 'under_review' | 'investigating' | 'mediation' | 'escalated' | 'resolved' | 'closed'
  currentStage: DisputeStage
  assignedTo?: string // Admin user ID
  
  // Evidence and documentation
  evidence: Evidence[]
  timeline: DisputeEvent[]
  communications: DisputeMessage[]
  
  // Resolution details
  resolution?: DisputeResolution
  compensation?: DisputeCompensation
  preventiveMeasures?: string[]
  
  // Metadata
  createdAt: Date
  updatedAt: Date
  resolvedAt?: Date
  escalatedAt?: Date
  deadlineAt: Date
}

export interface DisputeCategory {
  main: string
  sub: string
  tags: string[]
  autoResolutionEligible: boolean
  estimatedResolutionTime: number // hours
}

export interface Evidence {
  id: string
  type: 'photo' | 'document' | 'video' | 'screenshot' | 'receipt'
  url: string
  description: string
  submittedBy: string
  submittedAt: Date
  verified: boolean
}

export interface DisputeResolution {
  type: 'refund' | 'replacement' | 'credit' | 'compensation' | 'no_action'
  amount?: number
  reasoning: string
  resolvedBy: string
  resolvedAt: Date
  customerSatisfied: boolean
  preventiveMeasures: string[]
}

export class AdvancedDisputeManager {
  static async createDispute(
    disputeData: Partial<Dispute>
  ): Promise<Dispute> {
    // Categorize the dispute
    const category = await this.categorizeDispute(disputeData)
    
    // Calculate priority and severity
    const priority = await this.calculatePriority(disputeData, category)
    const severity = this.determineSeverity(disputeData, category)
    
    // Set deadline based on type and severity
    const deadline = this.calculateDeadline(category, severity)
    
    const dispute = await Dispute.create({
      ...disputeData,
      id: `DSP_${Date.now()}`,
      category,
      priority,
      severity,
      status: 'submitted',
      currentStage: 'initial_review',
      deadlineAt: deadline,
      timeline: [{
        type: 'created',
        description: 'Dispute submitted',
        timestamp: new Date(),
        actor: disputeData.customerId
      }]
    })
    
    // Auto-assign if possible
    await this.autoAssignDispute(dispute._id)
    
    // Check for auto-resolution eligibility
    if (category.autoResolutionEligible) {
      await this.attemptAutoResolution(dispute._id)
    }
    
    // Send notifications
    await this.sendDisputeNotifications(dispute, 'created')
    
    return dispute
  }
  
  static async escalateDispute(
    disputeId: string,
    escalationReason: string,
    escalatedBy: string
  ): Promise<void> {
    const dispute = await Dispute.findById(disputeId)
    if (!dispute) throw new Error('Dispute not found')
    
    // Update dispute status
    await Dispute.findByIdAndUpdate(disputeId, {
      status: 'escalated',
      escalatedAt: new Date(),
      $push: {
        timeline: {
          type: 'escalated',
          description: `Escalated: ${escalationReason}`,
          timestamp: new Date(),
          actor: escalatedBy
        }
      }
    })
    
    // Assign to senior admin or escalation team
    await this.assignToEscalationTeam(disputeId)
    
    // Extend deadline if necessary
    await this.extendDeadlineForEscalation(disputeId)
    
    // Send escalation notifications
    await this.sendEscalationNotifications(dispute, escalationReason)
  }
  
  static async resolveDispute(
    disputeId: string,
    resolution: DisputeResolution,
    resolvedBy: string
  ): Promise<void> {
    const dispute = await Dispute.findById(disputeId)
    if (!dispute) throw new Error('Dispute not found')
    
    try {
      // Process resolution actions
      await this.processResolutionActions(dispute, resolution)
      
      // Update dispute record
      await Dispute.findByIdAndUpdate(disputeId, {
        status: 'resolved',
        resolution,
        resolvedAt: new Date(),
        $push: {
          timeline: {
            type: 'resolved',
            description: `Resolved with ${resolution.type}`,
            timestamp: new Date(),
            actor: resolvedBy
          }
        }
      })
      
      // Update quality metrics
      await this.updateQualityMetrics(dispute, resolution)
      
      // Send resolution notifications
      await this.sendResolutionNotifications(dispute, resolution)
      
      // Schedule follow-up if needed
      await this.scheduleFollowUp(dispute, resolution)
      
    } catch (error) {
      console.error('Failed to resolve dispute:', error)
      throw new Error('Dispute resolution failed')
    }
  }
  
  private static async categorizeDispute(
    disputeData: Partial<Dispute>
  ): Promise<DisputeCategory> {
    // AI-based categorization
    const description = disputeData.description || ''
    const orderDetails = await Order.findById(disputeData.orderId)
    
    // Analyze keywords and context
    const keywords = this.extractKeywords(description)
    const context = this.analyzeOrderContext(orderDetails)
    
    // Determine main category
    let mainCategory = 'other'
    let subCategory = 'general'
    let autoResolutionEligible = false
    let estimatedTime = 72 // Default 72 hours
    
    if (keywords.includes('quality') || keywords.includes('defect')) {
      mainCategory = 'quality'
      subCategory = this.determineQualitySubcategory(keywords)
      estimatedTime = 48
    } else if (keywords.includes('late') || keywords.includes('delivery')) {
      mainCategory = 'delivery'
      subCategory = 'timing'
      estimatedTime = 24
      autoResolutionEligible = true
    } else if (keywords.includes('billing') || keywords.includes('charge')) {
      mainCategory = 'billing'
      subCategory = 'pricing'
      estimatedTime = 48
      autoResolutionEligible = true
    }
    
    return {
      main: mainCategory,
      sub: subCategory,
      tags: keywords,
      autoResolutionEligible,
      estimatedResolutionTime: estimatedTime
    }
  }
  
  private static async attemptAutoResolution(disputeId: string): Promise<boolean> {
    const dispute = await Dispute.findById(disputeId)
    if (!dispute) return false
    
    // Auto-resolution rules
    const rules = await this.getAutoResolutionRules(dispute.category)
    
    for (const rule of rules) {
      if (await this.evaluateRule(dispute, rule)) {
        await this.applyAutoResolution(dispute, rule)
        return true
      }
    }
    
    return false
  }
  
  private static async getAutoResolutionRules(
    category: DisputeCategory
  ): Promise<AutoResolutionRule[]> {
    // Example rules for different categories
    const rules: AutoResolutionRule[] = []
    
    if (category.main === 'delivery' && category.sub === 'timing') {
      rules.push({
        condition: 'order_delivered_late',
        action: 'partial_refund',
        amount: 0.1, // 10% refund
        maxAmount: 25,
        description: 'Automatic partial refund for late delivery'
      })
    }
    
    if (category.main === 'billing' && category.sub === 'pricing') {
      rules.push({
        condition: 'pricing_discrepancy_small',
        action: 'credit',
        amount: 'difference',
        description: 'Automatic credit for small pricing discrepancies'
      })
    }
    
    return rules
  }
  
  private static async processResolutionActions(
    dispute: Dispute,
    resolution: DisputeResolution
  ): Promise<void> {
    switch (resolution.type) {
      case 'refund':
        await this.processRefund(dispute, resolution.amount!)
        break
      case 'replacement':
        await this.processReplacement(dispute)
        break
      case 'credit':
        await this.processCredit(dispute, resolution.amount!)
        break
      case 'compensation':
        await this.processCompensation(dispute, resolution.amount!)
        break
    }
  }
  
  private static async processRefund(
    dispute: Dispute,
    amount: number
  ): Promise<void> {
    const order = await Order.findById(dispute.orderId)
    if (!order) throw new Error('Order not found')
    
    // Process Stripe refund
    const paymentIntent = await OrderPayment.findOne({ orderId: order._id })
    if (paymentIntent?.stripePaymentIntentId) {
      const refund = await stripe.refunds.create({
        payment_intent: paymentIntent.stripePaymentIntentId,
        amount: Math.round(amount * 100), // Convert to cents
        reason: 'requested_by_customer',
        metadata: {
          disputeId: dispute.id,
          orderId: order._id.toString()
        }
      })
      
      // Record refund
      await DisputeRefund.create({
        disputeId: dispute.id,
        orderId: order._id,
        amount,
        stripeRefundId: refund.id,
        processedAt: new Date()
      })
    }
    
    // Update order status
    await Order.findByIdAndUpdate(order._id, {
      'payment.refundAmount': amount,
      'payment.refundedAt': new Date()
    })
  }
  
  static async generateDisputeAnalytics(
    period: 'weekly' | 'monthly' | 'quarterly'
  ): Promise<DisputeAnalytics> {
    const dateRange = this.getDateRange(period)
    
    const disputes = await Dispute.find({
      createdAt: { $gte: dateRange.start, $lte: dateRange.end }
    })
    
    return {
      period,
      totalDisputes: disputes.length,
      byType: this.groupByType(disputes),
      bySeverity: this.groupBySeverity(disputes),
      resolutionTimes: this.calculateResolutionTimes(disputes),
      customerSatisfaction: this.calculateCustomerSatisfaction(disputes),
      autoResolutionRate: this.calculateAutoResolutionRate(disputes),
      trends: await this.calculateDisputeTrends(dateRange)
    }
  }
}
```

### Automated Refund Engine
**Rule-Based Refund Processing:**
```typescript
// lib/quality/refund-engine.ts
export interface RefundRule {
  id: string
  name: string
  active: boolean
  priority: number
  
  // Conditions
  conditions: RefundCondition[]
  
  // Actions
  refundType: 'full' | 'partial' | 'credit' | 'replacement'
  refundPercentage?: number
  maxRefundAmount?: number
  
  // Approval requirements
  requiresApproval: boolean
  approvalThreshold?: number
  
  // Metadata
  createdBy: string
  createdAt: Date
  lastModified: Date
}

export interface RefundCondition {
  field: string
  operator: 'equals' | 'greater_than' | 'less_than' | 'contains' | 'in'
  value: any
  weight: number
}

export class AutomatedRefundEngine {
  private static readonly REFUND_RULES: RefundRule[] = [
    {
      id: 'late_delivery_auto',
      name: 'Automatic Late Delivery Refund',
      active: true,
      priority: 10,
      conditions: [
        { field: 'delivery_delay_hours', operator: 'greater_than', value: 24, weight: 1.0 },
        { field: 'order_value', operator: 'less_than', value: 100, weight: 0.8 }
      ],
      refundType: 'partial',
      refundPercentage: 0.15,
      maxRefundAmount: 25,
      requiresApproval: false,
      createdBy: 'system',
      createdAt: new Date(),
      lastModified: new Date()
    },
    {
      id: 'quality_issue_major',
      name: 'Major Quality Issue Full Refund',
      active: true,
      priority: 20,
      conditions: [
        { field: 'issue_type', operator: 'in', value: ['print_quality', 'wrong_specifications'], weight: 1.0 },
        { field: 'issue_severity', operator: 'equals', value: 'high', weight: 0.9 },
        { field: 'customer_photos_provided', operator: 'equals', value: true, weight: 0.7 }
      ],
      refundType: 'full',
      requiresApproval: true,
      approvalThreshold: 200,
      createdBy: 'system',
      createdAt: new Date(),
      lastModified: new Date()
    }
  ]
  
  static async evaluateRefundEligibility(
    orderId: string,
    issueData: any
  ): Promise<RefundRecommendation> {
    const order = await Order.findById(orderId)
    if (!order) throw new Error('Order not found')
    
    const context = await this.buildRefundContext(order, issueData)
    
    // Evaluate all active rules
    const ruleEvaluations = []
    for (const rule of this.REFUND_RULES.filter(r => r.active)) {
      const evaluation = await this.evaluateRule(rule, context)
      if (evaluation.matches) {
        ruleEvaluations.push({ rule, evaluation })
      }
    }
    
    // Sort by priority and confidence
    ruleEvaluations.sort((a, b) => 
      b.rule.priority - a.rule.priority || 
      b.evaluation.confidence - a.evaluation.confidence
    )
    
    if (ruleEvaluations.length === 0) {
      return {
        eligible: false,
        recommendedAction: 'manual_review',
        reasoning: 'No automatic refund rules matched',
        confidence: 0
      }
    }
    
    const topMatch = ruleEvaluations[0]
    const refundAmount = await this.calculateRefundAmount(
      topMatch.rule,
      order,
      context
    )
    
    return {
      eligible: true,
      recommendedAction: topMatch.rule.refundType,
      refundAmount,
      refundPercentage: topMatch.rule.refundPercentage,
      requiresApproval: topMatch.rule.requiresApproval && 
                        refundAmount > (topMatch.rule.approvalThreshold || 0),
      reasoning: `Matched rule: ${topMatch.rule.name}`,
      confidence: topMatch.evaluation.confidence,
      ruleId: topMatch.rule.id
    }
  }
  
  static async processAutomaticRefund(
    orderId: string,
    recommendation: RefundRecommendation
  ): Promise<RefundResult> {
    if (!recommendation.eligible || recommendation.requiresApproval) {
      throw new Error('Refund requires manual approval')
    }
    
    const order = await Order.findById(orderId)
    if (!order) throw new Error('Order not found')
    
    try {
      let refundAmount = recommendation.refundAmount!
      
      // Process the refund based on type
      switch (recommendation.recommendedAction) {
        case 'full':
          refundAmount = order.pricing.total
          break
        case 'partial':
          // Amount already calculated
          break
        case 'credit':
          await this.processStoreCredit(order, refundAmount)
          return {
            success: true,
            type: 'credit',
            amount: refundAmount,
            processedAt: new Date()
          }
        case 'replacement':
          await this.processReplacement(order)
          return {
            success: true,
            type: 'replacement',
            processedAt: new Date()
          }
      }
      
      // Process monetary refund
      const refundResult = await this.processMonetaryRefund(order, refundAmount)
      
      // Record the automatic refund
      await AutoRefund.create({
        orderId: order._id,
        ruleId: recommendation.ruleId,
        amount: refundAmount,
        type: recommendation.recommendedAction,
        reasoning: recommendation.reasoning,
        confidence: recommendation.confidence,
        processedAt: new Date()
      })
      
      // Update order status
      await Order.findByIdAndUpdate(orderId, {
        'payment.refundAmount': refundAmount,
        'payment.refundedAt': new Date(),
        'payment.refundReason': 'automatic_rule_based'
      })
      
      // Send notifications
      await this.sendRefundNotifications(order, refundResult)
      
      return refundResult
      
    } catch (error) {
      console.error('Automatic refund processing failed:', error)
      throw new Error('Refund processing failed')
    }
  }
  
  private static async evaluateRule(
    rule: RefundRule,
    context: RefundContext
  ): Promise<RuleEvaluation> {
    let totalWeight = 0
    let matchedWeight = 0
    
    for (const condition of rule.conditions) {
      totalWeight += condition.weight
      
      if (this.evaluateCondition(condition, context)) {
        matchedWeight += condition.weight
      }
    }
    
    const confidence = matchedWeight / totalWeight
    const matches = confidence >= 0.7 // 70% threshold for rule matching
    
    return {
      matches,
      confidence,
      matchedConditions: rule.conditions.filter(c => 
        this.evaluateCondition(c, context)
      ).length,
      totalConditions: rule.conditions.length
    }
  }
  
  private static evaluateCondition(
    condition: RefundCondition,
    context: RefundContext
  ): boolean {
    const value = this.getContextValue(context, condition.field)
    
    switch (condition.operator) {
      case 'equals':
        return value === condition.value
      case 'greater_than':
        return value > condition.value
      case 'less_than':
        return value < condition.value
      case 'contains':
        return String(value).toLowerCase().includes(String(condition.value).toLowerCase())
      case 'in':
        return Array.isArray(condition.value) && condition.value.includes(value)
      default:
        return false
    }
  }
  
  private static async buildRefundContext(
    order: Order,
    issueData: any
  ): Promise<RefundContext> {
    const now = new Date()
    const estimatedCompletion = new Date(order.printShop.estimatedCompletion)
    const actualCompletion = order.printShop.actualCompletion ? 
      new Date(order.printShop.actualCompletion) : now
    
    return {
      order_value: order.pricing.total,
      order_age_hours: (now.getTime() - order.createdAt.getTime()) / (1000 * 60 * 60),
      delivery_delay_hours: Math.max(0, 
        (actualCompletion.getTime() - estimatedCompletion.getTime()) / (1000 * 60 * 60)
      ),
      issue_type: issueData.type,
      issue_severity: issueData.severity,
      customer_photos_provided: issueData.photos && issueData.photos.length > 0,
      customer_history: await this.getCustomerHistory(order.customer.userId),
      shop_quality_score: await this.getShopQualityScore(order.printShop.shopId),
      order_status: order.status,
      payment_method: order.payment.method,
      is_repeat_customer: await this.isRepeatCustomer(order.customer.userId)
    }
  }
  
  private static async processMonetaryRefund(
    order: Order,
    amount: number
  ): Promise<RefundResult> {
    const paymentIntent = await OrderPayment.findOne({ 
      orderId: order._id 
    })
    
    if (!paymentIntent?.stripePaymentIntentId) {
      throw new Error('No payment found for refund')
    }
    
    const refund = await stripe.refunds.create({
      payment_intent: paymentIntent.stripePaymentIntentId,
      amount: Math.round(amount * 100),
      reason: 'requested_by_customer',
      metadata: {
        orderId: order._id.toString(),
        automatic: 'true'
      }
    })
    
    return {
      success: true,
      type: 'monetary',
      amount,
      stripeRefundId: refund.id,
      processedAt: new Date()
    }
  }
}
```

### File Locations and Project Structure
- **Quality Pages**: `/app/admin/quality/page.tsx`, `/app/shop/quality/page.tsx`, `/app/disputes/page.tsx`
- **Dispute Components**: `/components/quality/dispute-dashboard.tsx`, `/components/quality/dispute-form.tsx`
- **Quality Components**: `/components/quality/quality-monitor.tsx`, `/components/quality/performance-dashboard.tsx`
- **Admin Tools**: `/components/admin/dispute-management.tsx`, `/components/admin/quality-oversight.tsx`
- **API Routes**: `/app/api/quality/`, `/app/api/disputes/`, `/app/api/refunds/`, `/app/api/admin/quality/`
- **Quality Engine**: `/lib/quality/advanced-monitoring.ts`, `/lib/quality/dispute-manager.ts`
- **Refund Engine**: `/lib/quality/refund-engine.ts`, `/lib/quality/automated-actions.ts`

## Testing

### Test Requirements
**Quality Monitoring Testing:**
```typescript
// __tests__/lib/quality/advanced-monitoring.test.ts
describe('AdvancedQualityMonitor', () => {
  it('calculates quality metrics correctly', async () => {
    const shopId = 'shop123'
    
    // Create test data
    await createMockOrders(shopId, 20, { completed: 18, late: 3 })
    await createMockReviews(shopId, 15, { averageRating: 4.2 })
    await createMockDisputes(shopId, 2, { resolved: 1 })
    
    const metrics = await AdvancedQualityMonitor.calculateQualityMetrics(shopId, 'monthly')
    
    expect(metrics.overall.score).toBeGreaterThan(70)
    expect(metrics.metrics.timeliness).toBe(0.85) // 17/20 on time
    expect(metrics.riskFactors.disputeRate).toBe(0.1) // 2/20 disputes
  })

  it('generates appropriate quality actions', async () => {
    const shopId = 'shop456'
    
    // Create concerning performance data
    await createMockOrders(shopId, 10, { completed: 6, cancelled: 3, late: 5 })
    
    const metrics = await AdvancedQualityMonitor.calculateQualityMetrics(shopId, 'weekly')
    
    expect(metrics.predictions.riskLevel).toBe('high')
    expect(metrics.predictions.recommendedActions).toContainEqual(
      expect.objectContaining({ type: 'warning' })
    )
  })
})
```

**Dispute Management Testing:**
```typescript
// __tests__/lib/quality/dispute-manager.test.ts
describe('AdvancedDisputeManager', () => {
  it('categorizes disputes correctly', async () => {
    const disputeData = {
      orderId: 'order123',
      description: 'The prints came out blurry and the colors were wrong',
      customerId: 'customer123'
    }
    
    const dispute = await AdvancedDisputeManager.createDispute(disputeData)
    
    expect(dispute.category.main).toBe('quality')
    expect(dispute.category.sub).toBe('print_defects')
    expect(dispute.severity).toBe('medium')
    expect(dispute.priority).toBeGreaterThan(5)
  })

  it('processes auto-resolution correctly', async () => {
    const disputeData = {
      orderId: 'order456',
      type: 'delivery',
      description: 'Order was delivered 48 hours late'
    }
    
    const dispute = await AdvancedDisputeManager.createDispute(disputeData)
    const resolved = await AdvancedDisputeManager.attemptAutoResolution(dispute._id)
    
    expect(resolved).toBe(true)
    
    const updatedDispute = await Dispute.findById(dispute._id)
    expect(updatedDispute.status).toBe('resolved')
    expect(updatedDispute.resolution.type).toBe('partial_refund')
  })
})
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-16 | 1.0 | Initial story creation from Epic 3 requirements | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by development agent_

### Debug Log References
_To be populated by development agent_

### Completion Notes List
_To be populated by development agent_

### File List
_To be populated by development agent_

## QA Results
_To be populated by QA agent_