# Story 2.1: Print Shop Directory & Onboarding

## Status
Draft

## Story
**As a** print shop owner and customer,  
**I want** a comprehensive print shop directory with onboarding and discovery features,  
**so that** print shops can join the platform and customers can find local shops.

## Acceptance Criteria

1. **Shop Registration**: Print shop onboarding with business verification and equipment details
2. **Shop Directory**: Searchable list and map view of registered print shops with filters
3. **Location Services**: GPS-based distance calculation and proximity sorting for customers
4. **Shop Profiles**: Detailed profiles with capabilities, specializations, hours, and contact information
5. **Pricing Display**: Transparent pricing for different print options (color, binding, paper types)
6. **Availability Status**: Real-time capacity indicators and current workload display
7. **Admin Approval**: Print shop verification workflow with document review and approval process

## Tasks / Subtasks

- [ ] **Task 1: Print Shop Registration and Onboarding** (AC: 1, 7)
  - [ ] Create print shop registration form with business details
  - [ ] Implement equipment and capabilities selection interface
  - [ ] Build business document upload system for verification
  - [ ] Add business hours configuration with timezone support
  - [ ] Create onboarding wizard with step-by-step guidance
  - [ ] Integrate with admin verification workflow from Story 1.4

- [ ] **Task 2: Shop Directory Interface** (AC: 2)
  - [ ] Create searchable directory with list and grid views
  - [ ] Implement search functionality by name, location, and services
  - [ ] Build filter system (services, distance, price range, ratings)
  - [ ] Add sorting options (distance, rating, price, availability)
  - [ ] Create responsive design for mobile and desktop

- [ ] **Task 3: Interactive Map Integration** (AC: 2, 3)
  - [ ] Integrate map component (Google Maps or Mapbox)
  - [ ] Display print shops as map markers with info windows
  - [ ] Implement GPS-based location detection for customers
  - [ ] Calculate and display distances from customer location
  - [ ] Add map clustering for areas with many shops

- [ ] **Task 4: Location Services and Geolocation** (AC: 3)
  - [ ] Implement browser geolocation API integration
  - [ ] Create address geocoding for print shop locations
  - [ ] Build proximity-based sorting algorithm
  - [ ] Add distance calculation utilities (Haversine formula)
  - [ ] Handle location permissions and privacy settings

- [ ] **Task 5: Detailed Shop Profiles** (AC: 4)
  - [ ] Create comprehensive shop profile pages
  - [ ] Display business information, photos, and contact details
  - [ ] Show equipment capabilities and specializations
  - [ ] Add business hours display with current status
  - [ ] Include customer reviews and ratings section

- [ ] **Task 6: Pricing Display System** (AC: 5)
  - [ ] Create pricing matrix for different print options
  - [ ] Build pricing calculator component
  - [ ] Display base prices and additional service costs
  - [ ] Add pricing comparison across shops
  - [ ] Implement dynamic pricing updates

- [ ] **Task 7: Availability and Capacity Management** (AC: 6)
  - [ ] Create real-time availability indicator system
  - [ ] Build capacity management interface for print shops
  - [ ] Implement workload tracking and display
  - [ ] Add estimated turnaround time calculations
  - [ ] Create availability API for real-time updates

- [ ] **Task 8: Directory and Shop Testing**
  - [ ] Test shop registration and verification flow
  - [ ] Test directory search and filtering functionality
  - [ ] Test map integration and location services
  - [ ] Test shop profile creation and editing
  - [ ] Verify responsive design and mobile experience

## Dev Notes

### Previous Story Insights
**Dependencies from Previous Stories:**
- Story 1.1: User collection schema with printShop role and business profile fields
- Story 1.2: Authentication system with role-based access control
- Story 1.4: Admin verification system and business document upload
- Story 1.5: Email notifications for verification status updates

### Database Schema for Print Shops
[Source: complete-architecture/database-architecture.md#users-collection]

**Print Shop Profile Schema:**
```typescript
interface User {
  // ... base user fields
  role: 'printShop'
  profile: {
    businessInfo: {
      name: string
      description: string
      capabilities: string[]  // ['color-printing', 'binding', 'large-format', 'same-day']
      equipment: string[]     // ['laser-printer', 'offset-press', 'wide-format']
      hours: {
        [day: string]: { open: string; close: string }  // '09:00', '17:00'
      }
      pricing: {
        [service: string]: number  // 'bw-page': 0.10, 'color-page': 0.25
      }
      location: {
        address: string
        city: string
        coordinates: [number, number] // [lng, lat]
        timezone: string
      }
      contact: {
        phone?: string
        website?: string
        socialMedia?: Record<string, string>
      }
      photos: string[]  // Cloudflare R2 URLs
    }
    isVerified: boolean
    verificationDocuments: string[]  // Document URLs
    verificationStatus: 'pending' | 'approved' | 'rejected'
    verificationNotes?: string
    
    // Capacity management
    capacity: {
      maxDailyOrders: number
      currentOrders: number
      estimatedTurnaround: number  // hours
      isAcceptingOrders: boolean
      lastUpdated: Date
    }
  }
}
```

### Database Indexes for Performance
[Source: complete-architecture/database-architecture.md#database-indexes]

**Additional Indexes for Print Shop Discovery:**
```javascript
// Geographic queries for proximity search
db.users.createIndex({ 
  "role": 1, 
  "profile.businessInfo.location.coordinates": "2dsphere" 
})

// Search and filtering
db.users.createIndex({ 
  "role": 1, 
  "profile.isVerified": 1, 
  "profile.capacity.isAcceptingOrders": 1 
})

// Text search for shop names and descriptions
db.users.createIndex({ 
  "$text": { 
    "profile.businessInfo.name": 1, 
    "profile.businessInfo.description": 1,
    "profile.businessInfo.capabilities": 1
  } 
})
```

### Shop Directory Component Architecture
[Source: complete-architecture/component-architecture.md#marketplace-components]

**Shop Directory Components:**
```typescript
// components/marketplace/shop-directory.tsx
interface ShopDirectoryProps {
  shops: PrintShop[]
  userLocation?: { lat: number; lng: number }
  view: 'list' | 'map' | 'grid'
  filters: {
    services: string[]
    maxDistance: number
    priceRange: [number, number]
    minRating: number
    acceptingOrders: boolean
  }
}

export function ShopDirectory({ shops, userLocation, view, filters }: ShopDirectoryProps) {
  const [filteredShops, setFilteredShops] = useState(shops)
  const [sortBy, setSortBy] = useState<'distance' | 'rating' | 'price'>('distance')

  const filterAndSortShops = useCallback(() => {
    let filtered = shops.filter(shop => {
      // Apply filters
      if (filters.acceptingOrders && !shop.capacity.isAcceptingOrders) return false
      if (filters.services.length > 0 && !filters.services.some(service => 
        shop.businessInfo.capabilities.includes(service)
      )) return false
      
      // Distance filter
      if (userLocation && filters.maxDistance > 0) {
        const distance = calculateDistance(userLocation, shop.businessInfo.location.coordinates)
        if (distance > filters.maxDistance) return false
      }
      
      return true
    })

    // Sort shops
    filtered.sort((a, b) => {
      switch (sortBy) {
        case 'distance':
          if (!userLocation) return 0
          const distA = calculateDistance(userLocation, a.businessInfo.location.coordinates)
          const distB = calculateDistance(userLocation, b.businessInfo.location.coordinates)
          return distA - distB
        case 'rating':
          return (b.rating || 0) - (a.rating || 0)
        case 'price':
          const avgPriceA = Object.values(a.businessInfo.pricing).reduce((a, b) => a + b, 0) / Object.values(a.businessInfo.pricing).length
          const avgPriceB = Object.values(b.businessInfo.pricing).reduce((a, b) => a + b, 0) / Object.values(b.businessInfo.pricing).length
          return avgPriceA - avgPriceB
        default:
          return 0
      }
    })

    setFilteredShops(filtered)
  }, [shops, filters, sortBy, userLocation])

  return (
    <div className="space-y-6">
      <ShopFilters filters={filters} onFiltersChange={setFilters} />
      <ShopSorting sortBy={sortBy} onSortChange={setSortBy} />
      
      {view === 'map' && (
        <ShopMap shops={filteredShops} userLocation={userLocation} />
      )}
      
      {view === 'list' && (
        <ShopList shops={filteredShops} userLocation={userLocation} />
      )}
      
      {view === 'grid' && (
        <ShopGrid shops={filteredShops} userLocation={userLocation} />
      )}
    </div>
  )
}
```

### Geolocation and Distance Calculation
**Location Services Implementation:**
```typescript
// lib/utils/geolocation.ts
export interface Coordinates {
  lat: number
  lng: number
}

export async function getCurrentLocation(): Promise<Coordinates> {
  return new Promise((resolve, reject) => {
    if (!navigator.geolocation) {
      reject(new Error('Geolocation is not supported'))
      return
    }

    navigator.geolocation.getCurrentPosition(
      (position) => {
        resolve({
          lat: position.coords.latitude,
          lng: position.coords.longitude
        })
      },
      (error) => {
        reject(new Error(`Geolocation error: ${error.message}`))
      },
      {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 300000 // 5 minutes
      }
    )
  })
}

// Haversine formula for calculating distances
export function calculateDistance(point1: Coordinates, point2: [number, number]): number {
  const R = 6371 // Earth's radius in kilometers
  const dLat = toRadians(point2[1] - point1.lat)
  const dLng = toRadians(point2[0] - point1.lng)
  
  const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(toRadians(point1.lat)) * Math.cos(toRadians(point2[1])) *
    Math.sin(dLng / 2) * Math.sin(dLng / 2)
  
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
  return R * c // Distance in kilometers
}

function toRadians(degrees: number): number {
  return degrees * (Math.PI / 180)
}

// Geocoding for address to coordinates
export async function geocodeAddress(address: string): Promise<Coordinates> {
  const response = await fetch(
    `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(address)}.json?access_token=${process.env.NEXT_PUBLIC_MAPBOX_TOKEN}`
  )
  
  const data = await response.json()
  
  if (data.features && data.features.length > 0) {
    const [lng, lat] = data.features[0].center
    return { lat, lng }
  }
  
  throw new Error('Address not found')
}
```

### Map Integration Component
```typescript
// components/marketplace/shop-map.tsx
import Map, { Marker, Popup } from 'react-map-gl'
import 'mapbox-gl/dist/mapbox-gl.css'

interface ShopMapProps {
  shops: PrintShop[]
  userLocation?: Coordinates
  onShopSelect?: (shop: PrintShop) => void
}

export function ShopMap({ shops, userLocation, onShopSelect }: ShopMapProps) {
  const [selectedShop, setSelectedShop] = useState<PrintShop | null>(null)
  const [viewport, setViewport] = useState({
    latitude: userLocation?.lat || 40.7128,
    longitude: userLocation?.lng || -74.0060,
    zoom: 12
  })

  return (
    <div className="h-96 w-full rounded-lg overflow-hidden">
      <Map
        {...viewport}
        onMove={evt => setViewport(evt.viewState)}
        mapboxAccessToken={process.env.NEXT_PUBLIC_MAPBOX_TOKEN}
        mapStyle="mapbox://styles/mapbox/streets-v11"
      >
        {/* User location marker */}
        {userLocation && (
          <Marker latitude={userLocation.lat} longitude={userLocation.lng}>
            <div className="w-4 h-4 bg-blue-500 rounded-full border-2 border-white shadow-lg" />
          </Marker>
        )}

        {/* Shop markers */}
        {shops.map(shop => (
          <Marker
            key={shop._id}
            latitude={shop.businessInfo.location.coordinates[1]}
            longitude={shop.businessInfo.location.coordinates[0]}
          >
            <button
              className="w-6 h-6 bg-red-500 rounded-full border-2 border-white shadow-lg hover:bg-red-600 transition-colors"
              onClick={() => setSelectedShop(shop)}
            />
          </Marker>
        ))}

        {/* Shop popup */}
        {selectedShop && (
          <Popup
            latitude={selectedShop.businessInfo.location.coordinates[1]}
            longitude={selectedShop.businessInfo.location.coordinates[0]}
            onClose={() => setSelectedShop(null)}
            closeButton={true}
            closeOnClick={false}
          >
            <ShopPopupCard 
              shop={selectedShop} 
              onViewDetails={() => onShopSelect?.(selectedShop)}
              userLocation={userLocation}
            />
          </Popup>
        )}
      </Map>
    </div>
  )
}
```

### Print Shop Capacity Management
**Real-time Availability System:**
```typescript
// lib/utils/capacity.ts
export interface ShopCapacity {
  maxDailyOrders: number
  currentOrders: number
  estimatedTurnaround: number
  isAcceptingOrders: boolean
  lastUpdated: Date
}

export function calculateAvailability(capacity: ShopCapacity): {
  status: 'available' | 'busy' | 'full'
  availabilityPercent: number
  estimatedWait: number
} {
  const utilizationRate = capacity.currentOrders / capacity.maxDailyOrders
  
  let status: 'available' | 'busy' | 'full'
  if (utilizationRate < 0.7) status = 'available'
  else if (utilizationRate < 0.9) status = 'busy'
  else status = 'full'

  const availabilityPercent = Math.max(0, (1 - utilizationRate) * 100)
  const estimatedWait = capacity.estimatedTurnaround * utilizationRate

  return {
    status,
    availabilityPercent,
    estimatedWait
  }
}

// API route for updating shop capacity
// /app/api/shops/capacity/route.ts
export async function PUT(request: NextRequest) {
  const session = await auth()
  if (!session?.user || session.user.role !== 'printShop') {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
  }

  const { maxDailyOrders, estimatedTurnaround, isAcceptingOrders } = await request.json()

  const updatedUser = await User.findByIdAndUpdate(
    session.user.id,
    {
      'profile.capacity.maxDailyOrders': maxDailyOrders,
      'profile.capacity.estimatedTurnaround': estimatedTurnaround,
      'profile.capacity.isAcceptingOrders': isAcceptingOrders,
      'profile.capacity.lastUpdated': new Date()
    },
    { new: true }
  )

  return NextResponse.json({ capacity: updatedUser.profile.capacity })
}
```

### File Locations and Project Structure
- **Shop Directory**: `/app/shops/page.tsx`, `/app/shops/[id]/page.tsx`
- **Shop Registration**: `/app/shop/register/page.tsx`, `/app/shop/onboarding/page.tsx`
- **Map Components**: `/components/marketplace/shop-map.tsx`
- **Directory Components**: `/components/marketplace/shop-directory.tsx`
- **API Routes**: `/app/api/shops/`, `/app/api/shops/search/`, `/app/api/shops/nearby/`
- **Utils**: `/lib/utils/geolocation.ts`, `/lib/utils/capacity.ts`

### API Routes Structure
```
/api/
├── shops/
│   ├── route.ts                 # GET shops, POST create shop
│   ├── [id]/route.ts           # GET, PUT, DELETE specific shop
│   ├── search/route.ts         # Search shops with filters
│   ├── nearby/route.ts         # Get shops by location
│   ├── capacity/route.ts       # Update shop capacity
│   └── verification/route.ts   # Admin verification endpoints
```

### Environment Variables Required
```bash
# Map Integration
NEXT_PUBLIC_MAPBOX_TOKEN=your-mapbox-token
# or
NEXT_PUBLIC_GOOGLE_MAPS_API_KEY=your-google-maps-key

# Geolocation Services
GEOCODING_API_KEY=your-geocoding-key
DEFAULT_MAP_CENTER_LAT=40.7128
DEFAULT_MAP_CENTER_LNG=-74.0060

# Business Verification
BUSINESS_VERIFICATION_WEBHOOK=https://...
MAX_VERIFICATION_DOCUMENTS=5
```

### Security and Privacy Considerations
- **Location Privacy**: User consent required for location access
- **Business Verification**: Secure document storage and admin-only access
- **Capacity Data**: Rate limiting on capacity updates
- **Search Performance**: Indexed queries and caching
- **Map API Security**: Token restrictions and usage monitoring

## Testing

### Test Requirements
[Source: complete-architecture/testing-strategy.md#component-testing]

**Shop Directory Testing:**
```typescript
// __tests__/components/marketplace/shop-directory.test.tsx
describe('ShopDirectory', () => {
  it('filters shops by services', async () => {
    const shops = [
      { ...mockShop, businessInfo: { ...mockShop.businessInfo, capabilities: ['color-printing'] } },
      { ...mockShop, businessInfo: { ...mockShop.businessInfo, capabilities: ['binding'] } }
    ]

    render(<ShopDirectory shops={shops} filters={{ services: ['color-printing'], maxDistance: 0, priceRange: [0, 100], minRating: 0, acceptingOrders: false }} />)

    expect(screen.getByText(shops[0].businessInfo.name)).toBeInTheDocument()
    expect(screen.queryByText(shops[1].businessInfo.name)).not.toBeInTheDocument()
  })

  it('sorts shops by distance when user location provided', () => {
    const userLocation = { lat: 40.7128, lng: -74.0060 }
    const nearShop = { ...mockShop, businessInfo: { ...mockShop.businessInfo, location: { coordinates: [-74.0050, 40.7130] } } }
    const farShop = { ...mockShop, businessInfo: { ...mockShop.businessInfo, location: { coordinates: [-74.0200, 40.7200] } } }

    render(<ShopDirectory shops={[farShop, nearShop]} userLocation={userLocation} />)

    const shopElements = screen.getAllByTestId('shop-card')
    expect(shopElements[0]).toHaveTextContent(nearShop.businessInfo.name)
  })
})
```

**Geolocation Testing:**
```typescript
// __tests__/lib/utils/geolocation.test.ts
describe('Geolocation Utils', () => {
  it('calculates distance correctly using Haversine formula', () => {
    const point1 = { lat: 40.7128, lng: -74.0060 } // NYC
    const point2: [number, number] = [-74.0050, 40.7130] // Near NYC
    
    const distance = calculateDistance(point1, point2)
    
    expect(distance).toBeCloseTo(0.15, 1) // ~0.15 km
  })

  it('handles geolocation API success', async () => {
    const mockGeolocation = {
      getCurrentPosition: jest.fn((success) => 
        success({
          coords: { latitude: 40.7128, longitude: -74.0060 }
        })
      )
    }
    
    global.navigator.geolocation = mockGeolocation

    const location = await getCurrentLocation()
    
    expect(location).toEqual({ lat: 40.7128, lng: -74.0060 })
  })
})
```

**Shop API Testing:**
```typescript
// __tests__/api/shops/search.test.ts
describe('/api/shops/search', () => {
  it('returns shops within specified distance', async () => {
    await User.create({
      role: 'printShop',
      profile: {
        businessInfo: {
          name: 'Local Print Shop',
          location: { coordinates: [-74.0060, 40.7128] }
        },
        isVerified: true
      }
    })

    const response = await GET('/api/shops/search?lat=40.7128&lng=-74.0060&maxDistance=5')
    
    expect(response.status).toBe(200)
    expect(response.body.shops).toHaveLength(1)
    expect(response.body.shops[0].businessInfo.name).toBe('Local Print Shop')
  })

  it('filters shops by capabilities', async () => {
    await User.create({
      role: 'printShop',
      profile: {
        businessInfo: {
          capabilities: ['color-printing', 'binding']
        },
        isVerified: true
      }
    })

    const response = await GET('/api/shops/search?capabilities=color-printing')
    
    expect(response.status).toBe(200)
    expect(response.body.shops).toHaveLength(1)
  })
})
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-16 | 1.0 | Initial story creation from Epic 2 requirements | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by development agent_

### Debug Log References
_To be populated by development agent_

### Completion Notes List
_To be populated by development agent_

### File List
_To be populated by development agent_

## QA Results
_To be populated by QA agent_