# Story 2.2: Content Creator Upload System

## Status
Draft

## Story
**As a** content creator,  
**I want** to upload educational materials with metadata and pricing,  
**so that** students can discover and order printed versions of my content.

## Acceptance Criteria

1. **File Upload Interface**: Drag-and-drop upload to Cloudflare R2 with progress indicators
2. **Content Metadata**: Form fields for title, description, subject, grade level, curriculum alignment, and tags
3. **Pricing Configuration**: Base pricing and markup percentages for different print options
4. **File Processing**: Automatic preview generation and format validation using existing infrastructure
5. **Content Library**: Creator dashboard to view, edit, and manage all uploaded content
6. **Draft System**: Save content as drafts before publishing with revision tracking
7. **Admin Moderation**: Content approval workflow with admin review before publication

## Tasks / Subtasks

- [ ] **Task 1: File Upload Interface Development** (AC: 1, 4)
  - [ ] Create drag-and-drop upload component with visual feedback
  - [ ] Implement file progress indicators and upload status
  - [ ] Integrate with Cloudflare R2 presigned URL system from Story 1.2
  - [ ] Add file validation (PDF, DOC, images) with user-friendly error messages
  - [ ] Implement preview generation for supported file formats

- [ ] **Task 2: Content Metadata Form System** (AC: 2)
  - [ ] Create comprehensive metadata form with validation
  - [ ] Build subject and grade level selection components
  - [ ] Implement curriculum alignment multi-select interface
  - [ ] Add tag system with autocomplete and custom tag creation
  - [ ] Create character counters and field validation

- [ ] **Task 3: Pricing Configuration Interface** (AC: 3)
  - [ ] Build pricing form with base price and markup settings
  - [ ] Create pricing calculator with real-time preview
  - [ ] Implement different pricing tiers (color, binding, paper types)
  - [ ] Add pricing suggestions based on content type and market data
  - [ ] Create pricing validation to ensure profitability

- [ ] **Task 4: File Processing and Preview System** (AC: 4)
  - [ ] Implement automatic file type detection and validation
  - [ ] Create PDF preview generation using PDF-lib or similar
  - [ ] Build document thumbnail creation system
  - [ ] Add file metadata extraction (page count, file size, etc.)
  - [ ] Implement virus scanning and content safety checks

- [ ] **Task 5: Creator Content Library Dashboard** (AC: 5)
  - [ ] Create content management dashboard for creators
  - [ ] Build content listing with search and filter capabilities
  - [ ] Implement content editing and update functionality
  - [ ] Add content analytics and performance metrics
  - [ ] Create bulk operations (delete, update status, etc.)

- [ ] **Task 6: Draft and Revision System** (AC: 6)
  - [ ] Implement content draft saving functionality
  - [ ] Create revision history tracking
  - [ ] Build draft preview and comparison tools
  - [ ] Add auto-save functionality for content forms
  - [ ] Implement version control for content updates

- [ ] **Task 7: Admin Moderation Workflow** (AC: 7)
  - [ ] Create admin content review interface
  - [ ] Implement content approval/rejection workflow
  - [ ] Build moderation queue with filtering and sorting
  - [ ] Add moderation notes and feedback system
  - [ ] Create automated content scanning for policy violations

- [ ] **Task 8: Content Upload System Testing**
  - [ ] Test file upload with various formats and sizes
  - [ ] Test metadata form validation and submission
  - [ ] Test pricing configuration and calculations
  - [ ] Test admin moderation workflow
  - [ ] Verify content library functionality and performance

## Dev Notes

### Previous Story Insights
**Dependencies from Previous Stories:**
- Story 1.1: Content collection schema with metadata and file references
- Story 1.2: Cloudflare R2 file upload system and NextAuth.js authentication
- Story 1.4: Creator role profiles and admin interfaces
- Story 1.5: Email notification system for moderation status updates

### Content Schema Integration
[Source: complete-architecture/database-architecture.md#content-collection]

**Content Collection Schema:**
```typescript
interface Content {
  _id: ObjectId
  title: string
  description: string
  creatorId: ObjectId (ref: User)
  
  metadata: {
    subject: string
    gradeLevel: string[]          // ['Grade 9', 'Grade 10', 'High School']
    curriculum: string[]          // ['Common Core', 'AP', 'IB']
    tags: string[]               // ['algebra', 'worksheets', 'practice']
    fileType: string             // 'application/pdf'
    fileSize: number             // bytes
    pageCount?: number
    language: string             // 'en', 'es', 'fr'
    difficulty: 'beginner' | 'intermediate' | 'advanced'
  }
  
  file: {
    url: string                  // Cloudflare R2 URL
    cdnUrl: string              // CDN optimized URL
    key: string                 // R2 object key
    previewUrl?: string         // Thumbnail/preview URL
    thumbnailUrl?: string       // Small thumbnail
  }
  
  pricing: {
    basePrice: number           // Base content price
    markup: {
      color: number             // Color printing markup %
      binding: number           // Binding markup %
      lamination: number        // Lamination markup %
    }
    suggested: {
      bwPerPage: number         // Suggested B&W price per page
      colorPerPage: number      // Suggested color price per page
    }
  }
  
  stats: {
    views: number
    orders: number
    revenue: number
    rating: number
    reviewCount: number
    downloadCount: number
  }
  
  status: 'draft' | 'pending' | 'approved' | 'rejected' | 'archived'
  moderationNotes?: string
  moderationDate?: Date
  moderatedBy?: ObjectId (ref: User)
  
  // Draft and revision system
  isDraft: boolean
  publishedVersion?: ObjectId (ref: Content)
  revisionHistory: [{
    version: number
    changes: string[]
    createdAt: Date
    createdBy: ObjectId (ref: User)
  }]
  
  createdAt: Date
  updatedAt: Date
}
```

### File Upload Integration
[Source: complete-architecture/file-management-architecture.md#file-upload-api-route]

**Enhanced Content Upload API:**
```typescript
// /api/content/upload/route.ts
export async function POST(request: NextRequest) {
  const session = await auth()
  if (!session?.user || session.user.role !== 'creator') {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
  }

  const { fileName, fileType, fileSize, contentMetadata } = await request.json()
  
  // Validate file for content upload
  const allowedTypes = [
    'application/pdf',
    'application/msword',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    'image/jpeg',
    'image/png'
  ]
  const maxSize = 50 * 1024 * 1024 // 50MB

  if (!allowedTypes.includes(fileType) || fileSize > maxSize) {
    return NextResponse.json({ 
      error: "Invalid file. Supported formats: PDF, DOC, DOCX, JPG, PNG. Max size: 50MB" 
    }, { status: 400 })
  }

  // Generate unique key for content
  const sanitizedFileName = fileName.replace(/[^a-zA-Z0-9.-]/g, '_')
  const key = `content/${session.user.id}/${Date.now()}-${sanitizedFileName}`
  
  // Generate presigned URL
  const uploadUrl = await generatePresignedUploadUrl(key, fileType, 3600)
  
  // Create draft content record
  const content = await Content.create({
    title: contentMetadata.title || fileName,
    description: contentMetadata.description || '',
    creatorId: session.user.id,
    metadata: {
      ...contentMetadata,
      fileType,
      fileSize
    },
    file: {
      key,
      url: '', // Will be updated after upload confirmation
      cdnUrl: getCDNUrl(key)
    },
    status: 'draft',
    isDraft: true,
    stats: {
      views: 0,
      orders: 0,
      revenue: 0,
      rating: 0,
      reviewCount: 0,
      downloadCount: 0
    }
  })
  
  return NextResponse.json({
    uploadUrl,
    contentId: content._id,
    key,
    cdnUrl: getCDNUrl(key)
  })
}
```

### Content Metadata Form Architecture
**Comprehensive Metadata Interface:**
```typescript
// components/content/content-upload-form.tsx
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { contentMetadataSchema } from '@/lib/validations/content'

interface ContentMetadata {
  title: string
  description: string
  subject: string
  gradeLevel: string[]
  curriculum: string[]
  tags: string[]
  language: string
  difficulty: 'beginner' | 'intermediate' | 'advanced'
  pricing: {
    basePrice: number
    markup: {
      color: number
      binding: number
      lamination: number
    }
  }
}

export function ContentUploadForm() {
  const form = useForm<ContentMetadata>({
    resolver: zodResolver(contentMetadataSchema),
    defaultValues: {
      title: '',
      description: '',
      subject: '',
      gradeLevel: [],
      curriculum: [],
      tags: [],
      language: 'en',
      difficulty: 'intermediate',
      pricing: {
        basePrice: 2.99,
        markup: {
          color: 25,
          binding: 15,
          lamination: 10
        }
      }
    }
  })

  return (
    <Form {...form}>
      <div className="space-y-6">
        {/* Basic Information */}
        <div className="space-y-4">
          <h3 className="text-lg font-semibold">Basic Information</h3>
          
          <FormField
            control={form.control}
            name="title"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Title *</FormLabel>
                <FormControl>
                  <Input placeholder="Enter content title" {...field} />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="description"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Description</FormLabel>
                <FormControl>
                  <Textarea
                    placeholder="Describe your educational content..."
                    className="min-h-[100px]"
                    {...field}
                  />
                </FormControl>
                <FormDescription>
                  {field.value.length}/500 characters
                </FormDescription>
                <FormMessage />
              </FormItem>
            )}
          />
        </div>

        {/* Educational Metadata */}
        <div className="space-y-4">
          <h3 className="text-lg font-semibold">Educational Details</h3>
          
          <FormField
            control={form.control}
            name="subject"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Subject *</FormLabel>
                <Select onValueChange={field.onChange} defaultValue={field.value}>
                  <FormControl>
                    <SelectTrigger>
                      <SelectValue placeholder="Select subject" />
                    </SelectTrigger>
                  </FormControl>
                  <SelectContent>
                    <SelectItem value="mathematics">Mathematics</SelectItem>
                    <SelectItem value="science">Science</SelectItem>
                    <SelectItem value="english">English</SelectItem>
                    <SelectItem value="history">History</SelectItem>
                    <SelectItem value="foreign-language">Foreign Language</SelectItem>
                  </SelectContent>
                </Select>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="gradeLevel"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Grade Level *</FormLabel>
                <FormControl>
                  <MultiSelect
                    options={gradeLevelOptions}
                    value={field.value}
                    onChange={field.onChange}
                    placeholder="Select grade levels"
                  />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="tags"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Tags</FormLabel>
                <FormControl>
                  <TagInput
                    value={field.value}
                    onChange={field.onChange}
                    placeholder="Add tags..."
                    suggestions={tagSuggestions}
                  />
                </FormControl>
                <FormDescription>
                  Add relevant tags to help students find your content
                </FormDescription>
                <FormMessage />
              </FormItem>
            )}
          />
        </div>

        {/* Pricing Configuration */}
        <PricingConfigurationSection form={form} />
      </div>
    </Form>
  )
}
```

### Pricing Configuration System
**Dynamic Pricing Calculator:**
```typescript
// components/content/pricing-configuration.tsx
interface PricingConfigurationProps {
  form: UseFormReturn<ContentMetadata>
}

export function PricingConfigurationSection({ form }: PricingConfigurationProps) {
  const basePrice = form.watch('pricing.basePrice')
  const markup = form.watch('pricing.markup')
  
  const calculatePrintingCosts = (pages: number = 10) => {
    const baseCostPerPage = 0.05 // Platform base cost
    const colorMultiplier = 1 + (markup.color / 100)
    const bindingCost = markup.binding / 100 * basePrice
    const laminationCost = markup.lamination / 100 * basePrice

    return {
      content: basePrice,
      bwPrinting: pages * baseCostPerPage,
      colorPrinting: pages * baseCostPerPage * colorMultiplier,
      binding: bindingCost,
      lamination: laminationCost,
      total: {
        bw: basePrice + (pages * baseCostPerPage) + bindingCost,
        color: basePrice + (pages * baseCostPerPage * colorMultiplier) + bindingCost,
        premium: basePrice + (pages * baseCostPerPage * colorMultiplier) + bindingCost + laminationCost
      }
    }
  }

  const costs = calculatePrintingCosts()

  return (
    <div className="space-y-4">
      <h3 className="text-lg font-semibold">Pricing Configuration</h3>
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div className="space-y-4">
          <FormField
            control={form.control}
            name="pricing.basePrice"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Base Content Price ($)</FormLabel>
                <FormControl>
                  <Input
                    type="number"
                    step="0.01"
                    min="0.99"
                    placeholder="2.99"
                    {...field}
                    onChange={(e) => field.onChange(parseFloat(e.target.value))}
                  />
                </FormControl>
                <FormDescription>
                  The price students pay for your content
                </FormDescription>
                <FormMessage />
              </FormItem>
            )}
          />

          <div className="grid grid-cols-3 gap-2">
            <FormField
              control={form.control}
              name="pricing.markup.color"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Color (%)</FormLabel>
                  <FormControl>
                    <Input
                      type="number"
                      min="0"
                      max="100"
                      {...field}
                      onChange={(e) => field.onChange(parseInt(e.target.value))}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="pricing.markup.binding"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Binding (%)</FormLabel>
                  <FormControl>
                    <Input
                      type="number"
                      min="0"
                      max="50"
                      {...field}
                      onChange={(e) => field.onChange(parseInt(e.target.value))}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="pricing.markup.lamination"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Lamination (%)</FormLabel>
                  <FormControl>
                    <Input
                      type="number"
                      min="0"
                      max="30"
                      {...field}
                      onChange={(e) => field.onChange(parseInt(e.target.value))}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          </div>
        </div>

        <div className="bg-gray-50 p-4 rounded-lg">
          <h4 className="font-medium mb-3">Pricing Preview (10 pages)</h4>
          <div className="space-y-2 text-sm">
            <div className="flex justify-between">
              <span>Content:</span>
              <span>${costs.content.toFixed(2)}</span>
            </div>
            <div className="flex justify-between">
              <span>B&W Printing:</span>
              <span>${costs.bwPrinting.toFixed(2)}</span>
            </div>
            <div className="flex justify-between">
              <span>Color Printing:</span>
              <span>${costs.colorPrinting.toFixed(2)}</span>
            </div>
            <Separator />
            <div className="flex justify-between font-medium">
              <span>Total (B&W):</span>
              <span>${costs.total.bw.toFixed(2)}</span>
            </div>
            <div className="flex justify-between font-medium">
              <span>Total (Color):</span>
              <span>${costs.total.color.toFixed(2)}</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
```

### Content Library Dashboard
**Creator Content Management:**
```typescript
// components/content/content-library.tsx
export function ContentLibrary() {
  const [contents, setContents] = useState<Content[]>([])
  const [filters, setFilters] = useState({
    status: 'all',
    search: '',
    subject: '',
    sortBy: 'createdAt'
  })

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h2 className="text-2xl font-bold">Content Library</h2>
        <Button asChild>
          <Link href="/creator/upload">
            <Plus className="mr-2 h-4 w-4" />
            Upload Content
          </Link>
        </Button>
      </div>

      <ContentFilters filters={filters} onFiltersChange={setFilters} />

      <div className="grid gap-4">
        {contents.map((content) => (
          <ContentCard
            key={content._id}
            content={content}
            variant="creator"
            actions={{
              onEdit: (id) => router.push(`/creator/content/${id}/edit`),
              onDelete: handleDelete,
              onPublish: handlePublish,
              onViewAnalytics: (id) => router.push(`/creator/content/${id}/analytics`)
            }}
          />
        ))}
      </div>

      <ContentPagination
        currentPage={pagination.page}
        totalPages={pagination.totalPages}
        onPageChange={handlePageChange}
      />
    </div>
  )
}
```

### Admin Moderation Interface
**Content Review Dashboard:**
```typescript
// components/admin/content-moderation.tsx
export function ContentModerationDashboard() {
  const [pendingContent, setPendingContent] = useState<Content[]>([])
  const [selectedContent, setSelectedContent] = useState<Content | null>(null)

  const handleModeration = async (contentId: string, action: 'approve' | 'reject', notes?: string) => {
    try {
      await fetch(`/api/admin/content/${contentId}/moderate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action, notes })
      })
      
      // Refresh pending content
      fetchPendingContent()
      
      // Send notification to creator
      await sendModerationNotification(contentId, action, notes)
    } catch (error) {
      console.error('Moderation failed:', error)
    }
  }

  return (
    <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
      <div className="lg:col-span-2">
        <h2 className="text-xl font-semibold mb-4">Pending Content Review</h2>
        <div className="space-y-4">
          {pendingContent.map((content) => (
            <ContentModerationCard
              key={content._id}
              content={content}
              onSelect={setSelectedContent}
              onQuickApprove={(id) => handleModeration(id, 'approve')}
              onQuickReject={(id) => handleModeration(id, 'reject')}
            />
          ))}
        </div>
      </div>

      <div>
        {selectedContent && (
          <ContentDetailPanel
            content={selectedContent}
            onModerate={handleModeration}
          />
        )}
      </div>
    </div>
  )
}
```

### File Processing and Preview Generation
**Document Processing Pipeline:**
```typescript
// lib/content/processing.ts
export class ContentProcessor {
  static async processUploadedFile(fileKey: string, fileType: string): Promise<ProcessingResult> {
    try {
      const fileUrl = getCDNUrl(fileKey)
      const result: ProcessingResult = {
        previewUrl: '',
        thumbnailUrl: '',
        pageCount: 0,
        metadata: {}
      }

      switch (fileType) {
        case 'application/pdf':
          result = await this.processPDF(fileUrl, fileKey)
          break
        case 'application/msword':
        case 'application/vnd.openxmlformats-officedocument.wordprocessingml.document':
          result = await this.processDocument(fileUrl, fileKey)
          break
        case 'image/jpeg':
        case 'image/png':
          result = await this.processImage(fileUrl, fileKey)
          break
        default:
          throw new Error(`Unsupported file type: ${fileType}`)
      }

      // Run content safety scan
      await this.runSafetyCheck(fileUrl)

      return result
    } catch (error) {
      console.error('File processing failed:', error)
      throw error
    }
  }

  private static async processPDF(fileUrl: string, fileKey: string): Promise<ProcessingResult> {
    // PDF processing logic
    const pdfDoc = await PDFDocument.load(await fetch(fileUrl).then(r => r.arrayBuffer()))
    const pageCount = pdfDoc.getPageCount()
    
    // Generate thumbnail from first page
    const thumbnailKey = fileKey.replace(/\.[^/.]+$/, '-thumb.jpg')
    const thumbnailUrl = await this.generatePDFThumbnail(fileUrl, thumbnailKey)
    
    // Generate preview (first 3 pages)
    const previewKey = fileKey.replace(/\.[^/.]+$/, '-preview.pdf')
    const previewUrl = await this.generatePDFPreview(fileUrl, previewKey, 3)

    return {
      previewUrl,
      thumbnailUrl,
      pageCount,
      metadata: {
        type: 'pdf',
        pages: pageCount
      }
    }
  }

  private static async runSafetyCheck(fileUrl: string): Promise<void> {
    // Implement content safety checking
    // - Virus scanning
    // - Inappropriate content detection
    // - Copyright violation checking
    const safetyResult = await fetch('/api/content/safety-check', {
      method: 'POST',
      body: JSON.stringify({ fileUrl })
    })

    if (!safetyResult.ok) {
      throw new Error('Content safety check failed')
    }
  }
}
```

### File Locations and Project Structure
- **Upload Interface**: `/app/creator/upload/page.tsx`
- **Content Library**: `/app/creator/content/page.tsx`, `/app/creator/content/[id]/page.tsx`
- **Admin Moderation**: `/app/admin/content/page.tsx`
- **Upload Components**: `/components/content/upload-form.tsx`, `/components/content/file-dropzone.tsx`
- **Library Components**: `/components/content/content-library.tsx`, `/components/content/content-card.tsx`
- **API Routes**: `/app/api/content/`, `/app/api/content/upload/`, `/app/api/admin/content/`
- **Processing Utils**: `/lib/content/processing.ts`, `/lib/content/validation.ts`

### Environment Variables Required
```bash
# Content Processing
CONTENT_PROCESSING_ENABLED=true
PDF_PROCESSING_API_KEY=your-pdf-api-key
CONTENT_SAFETY_API_KEY=your-safety-api-key

# File Storage Limits
MAX_CONTENT_FILE_SIZE=52428800  # 50MB
ALLOWED_CONTENT_TYPES=application/pdf,application/msword,image/jpeg,image/png

# Moderation
AUTO_APPROVAL_ENABLED=false
CONTENT_REVIEW_WEBHOOK=https://...
```

## Testing

### Test Requirements
[Source: complete-architecture/testing-strategy.md#component-testing]

**Content Upload Testing:**
```typescript
// __tests__/components/content/upload-form.test.tsx
describe('ContentUploadForm', () => {
  it('validates required fields before submission', async () => {
    render(<ContentUploadForm />)
    
    fireEvent.click(screen.getByText('Upload Content'))
    
    await waitFor(() => {
      expect(screen.getByText('Title is required')).toBeInTheDocument()
      expect(screen.getByText('Subject is required')).toBeInTheDocument()
    })
  })

  it('calculates pricing correctly based on markup', () => {
    render(<ContentUploadForm />)
    
    fireEvent.change(screen.getByLabelText('Base Content Price'), {
      target: { value: '5.00' }
    })
    fireEvent.change(screen.getByLabelText('Color (%)'), {
      target: { value: '30' }
    })
    
    expect(screen.getByText('Total (Color):')).toHaveTextContent('$6.15') // 5.00 + (0.50 * 1.30)
  })
})
```

**Content Processing Testing:**
```typescript
// __tests__/lib/content/processing.test.ts
describe('ContentProcessor', () => {
  it('processes PDF files and extracts metadata', async () => {
    const mockPDFBuffer = await fs.readFile('test-files/sample.pdf')
    global.fetch = jest.fn().mockResolvedValue({
      arrayBuffer: () => Promise.resolve(mockPDFBuffer)
    })

    const result = await ContentProcessor.processUploadedFile(
      'content/user123/sample.pdf',
      'application/pdf'
    )

    expect(result.pageCount).toBeGreaterThan(0)
    expect(result.thumbnailUrl).toBeDefined()
    expect(result.previewUrl).toBeDefined()
  })

  it('rejects unsafe content', async () => {
    global.fetch = jest.fn().mockResolvedValue({
      ok: false,
      status: 400
    })

    await expect(
      ContentProcessor.processUploadedFile('unsafe-content.pdf', 'application/pdf')
    ).rejects.toThrow('Content safety check failed')
  })
})
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-16 | 1.0 | Initial story creation from Epic 2 requirements | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by development agent_

### Debug Log References
_To be populated by development agent_

### Completion Notes List
_To be populated by development agent_

### File List
_To be populated by development agent_

## QA Results
_To be populated by QA agent_